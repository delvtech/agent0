--------------------------------------------------------------------
## simulators.py
--------------------------------------------------------------------
The simulator will track the current simulation time

## simulator.run_simulation
"""
Easy version --
one trade per block
easier, but doesn't allow for MEV or gas simulation

The user can view the full market state (whatever set of variables we want to make public).
Based on these, the user parses their strategy and returns some action.
The market executes this action & returns the user state deltas (like updating their # of ptDAI).
The user updates their state with the market output, and then we move on to the next user.
So N users can trade in one time iteration (as indicated by `time_idx`), but each user gets to see the prev user's actions before deciding their own.
If all N users buy, then they all get tokens minted with `(day, time_idx)` coded as the mint date.
"""
for day in range(num_trading_days):
    for block_idx in range(blocks_per_day): # discretized time
        for user in shuffle(users): # random order; all users get a chance to trade
            market_action = user.get_action(market) # user gets current market state
            user_state_update = market.execute_trade(market_action) # includes market state update
            user.update_state(user_state_update)
            simulator.update_analysis_dict(user_state, market_state)
        market.tick()


"""
Future version --
multiple random trades per block
needs to support "gas" so users can adjust their priority (users.time_weightings)
needs to support market safety mechanism to cancel trades if there is high slippage
needs user contingent contracts that cancel trades if there is too much slippage
"""
for day in range(num_trading_days):
    for time_idx in range(times_per_day): # discretized time
        # minimum time pass between blocks of trades
        shuffled_users = shuffle(users, weights=users.time_weightings) # random transaction ordering on the block
        for user in shuffled_users: # random order in a block
            action_list.append(user.get_action(market))
        # user_state_updates includes deltas for every user state variable
        user_state_updates = market.execute_trades(action_list)
        for user, state in zip(shuffled_users, user_state_updates):
            user.update_state(state)
        simulator.update_analysis_dict(user_states, market_state)
        market.tick()


--------------------------------------------------------------------
## markets.py
Future version -- auto-protect: if slippage is too big, stop execution
--------------------------------------------------------------------
The market will have no notion of time.
Calls to market.swap() will now also include a normalized time_remaining that is 0 at token mint time and 1 at token expiry time.
This variable will get passed to the respective pricing model functions.
The simulator will track the current simulation time, and the tokens will track their individual mint times.

market.execute_trade(action):
    # execute the given trade
    # update internal market state
    #    user specifies amounts,
    #        e.g. "buy 100DAI worth of ptDAI"
    #    market computes volume of minted token & user deltas,
    #        e.g. "user budget has 100 less DAI; 95 more ptDAI";
    #             "market has 100 more DAI";
    # return user state deltas


--------------------------------------------------------------------
## users.py
--------------------------------------------------------------------
user wallet
   keys are dates (block number instead? what tokens are fungible?)
   values are quantity of tokens purchased for that date
   tokens are only fungible if they were minted in the same block
wallet = {
    "2022-11-01": 23,
    "2022-11-13": 500
}
probably makes sense to include a user.wallet inner class
this would support helper functions on the wallet, like "get_oldest_pt"; "get_largest_pt"

user trading strategies are encoded in json files,
with one file per user in the `root/users`(elsewhere?) directory
e.g.:

`examples/user_policies/example_policy_1.json`
"policy": {
    "type": "example_trader",
    "budget": 1000,
    "trade": {"sell": {"amount": 100}}
}

`examples/user_policies/example_policy_2.json`
"policy" : {
    "type": "example_trader",
    "budget": 1000,
    "trade": {
        "conditional": {
            "if": {">": ["market.pool_apy", 0.5]},
            "then": {"buy": {"amount": 100}},
            "else": "none"
        }
    }
}

`examples/user_policies/example_policy_3.json`
"policy" : {
    "type": "example_trader",
    "budget": 1000,
    "trade": {
        "conditional": {
            "if": {
                "==": [
                    {"rand_variable": {
                        "method": "random",
                        "distribution": "integers",
                        "low": 0,
                        "high": 2
                    }},
                    0
                ]
            },
            "then": {"buy": {"amount": 100}},
            "else": {"sell": {"amount": 100}}
        }
    }
}

`examples/user_policies/example_policy_4.json`
"policy" : {
    "type": "example_trader",
    "budget": 1000,
    "trade":{
        "conditional": {
            "if": {
                "and": {
                    ">": ["market.pool_apy", 0.5],
                    "<=": ["market.vault_apy", 0.9]
                }
            },
            "then": {
                "buy": {
                    "amount": {
                        "method": "random",
                        "distribution": "gaussian",
                        "mean": 100,
                        "std": 10
                    }
                }
            },
            "else": "none"
        }
    }
}

`examples/user_policies/example_policy_5.json`
"policy": {
    "type": "example_trader",
    "budget": 1000,
    "trade": {
        "conditional": {
            "if": {
                "and": {
                    ">": ["market.pool_apy", 0.5],
                    ">=": ["user.wallet.oldest_token", 85]
                }
            },
            "then": {
                "buy": {
                    "amount": {
                        "method": "random",
                        "distribution": "gaussian",
                        "mean": 100,
                        "std": 10
                    }
                }
            },
            "else": "none"
        }
    }
}

user.get_trade(market):
    # given market conditions, execute a user trading strategy
    # this function will convert the user's json policy into actions
    # return (token_in, token_out, buy_amount) OR None

user.update_state(user_state_update):
    # update all of the user member variables (e.g. wallet)
    # using the member state that was returned from the market
