"""A web3.py Contract class for the IMorphoBlueHyperdrive contract.

DO NOT EDIT.  This file was generated by pypechain.  See documentation at
https://github.com/delvtech/pypechain"""

# contracts have PascalCase names
# pylint: disable=invalid-name

# contracts control how many attributes and arguments we have in generated code
# pylint: disable=too-many-instance-attributes
# pylint: disable=too-many-arguments

# we don't need else statement if the other conditionals all have return,
# but it's easier to generate
# pylint: disable=no-else-return

# This file is bound to get very long depending on contract sizes.
# pylint: disable=too-many-lines

# methods are overriden with specific arguments instead of generic *args, **kwargs
# pylint: disable=arguments-differ

# consumers have too many opinions on line length
# pylint: disable=line-too-long


from __future__ import annotations

from typing import Any, Iterable, NamedTuple, Sequence, Type, cast, overload

from eth_abi.codec import ABICodec
from eth_abi.registry import registry as default_registry
from eth_account.signers.local import LocalAccount
from eth_typing import ChecksumAddress, HexStr
from hexbytes import HexBytes
from typing_extensions import Self
from web3 import Web3
from web3._utils.filters import LogFilter
from web3.contract.contract import (
    Contract,
    ContractConstructor,
    ContractEvent,
    ContractEvents,
    ContractFunction,
    ContractFunctions,
)
from web3.exceptions import FallbackNotFound
from web3.types import ABI, ABIFunction, BlockIdentifier, CallOverride, EventData, TxParams

from .IHyperdriveTypes import Checkpoint, Fees, MarketState, Options, PoolConfig, PoolInfo, WithdrawPool
from .utilities import dataclass_to_tuple, get_abi_input_types, rename_returned_types, try_bytecode_hexbytes

structs = {
    "Options": Options,
    "Checkpoint": Checkpoint,
    "MarketState": MarketState,
    "Fees": Fees,
    "PoolConfig": PoolConfig,
    "PoolInfo": PoolInfo,
    "WithdrawPool": WithdrawPool,
}


class IMorphoBlueHyperdrivePERMIT_TYPEHASHContractFunction(ContractFunction):
    """ContractFunction for the PERMIT_TYPEHASH method."""

    def __call__(self) -> IMorphoBlueHyperdrivePERMIT_TYPEHASHContractFunction:  # type: ignore
        clone = super().__call__()
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: CallOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bytes:
        """returns bytes."""
        # Define the expected return types from the smart contract call

        return_types = bytes

        # Call the function

        raw_values = super().call(transaction, block_identifier, state_override, ccip_read_enabled)
        return cast(bytes, rename_returned_types(structs, return_types, raw_values))


class IMorphoBlueHyperdriveAddLiquidityContractFunction(ContractFunction):
    """ContractFunction for the addLiquidity method."""

    def __call__(self, contribution: int, minLpSharePrice: int, minApr: int, maxApr: int, options: Options) -> IMorphoBlueHyperdriveAddLiquidityContractFunction:  # type: ignore
        clone = super().__call__(
            dataclass_to_tuple(contribution),
            dataclass_to_tuple(minLpSharePrice),
            dataclass_to_tuple(minApr),
            dataclass_to_tuple(maxApr),
            dataclass_to_tuple(options),
        )
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: CallOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # Define the expected return types from the smart contract call

        return_types = int

        # Call the function

        raw_values = super().call(transaction, block_identifier, state_override, ccip_read_enabled)
        return cast(int, rename_returned_types(structs, return_types, raw_values))


class IMorphoBlueHyperdriveBalanceOfContractFunction(ContractFunction):
    """ContractFunction for the balanceOf method."""

    def __call__(self, tokenId: int, owner: str) -> IMorphoBlueHyperdriveBalanceOfContractFunction:  # type: ignore
        clone = super().__call__(dataclass_to_tuple(tokenId), dataclass_to_tuple(owner))
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: CallOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # Define the expected return types from the smart contract call

        return_types = int

        # Call the function

        raw_values = super().call(transaction, block_identifier, state_override, ccip_read_enabled)
        return cast(int, rename_returned_types(structs, return_types, raw_values))


class IMorphoBlueHyperdriveBaseTokenContractFunction(ContractFunction):
    """ContractFunction for the baseToken method."""

    def __call__(self) -> IMorphoBlueHyperdriveBaseTokenContractFunction:  # type: ignore
        clone = super().__call__()
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: CallOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # Define the expected return types from the smart contract call

        return_types = str

        # Call the function

        raw_values = super().call(transaction, block_identifier, state_override, ccip_read_enabled)
        return cast(str, rename_returned_types(structs, return_types, raw_values))


class IMorphoBlueHyperdriveBatchTransferFromContractFunction(ContractFunction):
    """ContractFunction for the batchTransferFrom method."""

    def __call__(self, _from: str, to: str, ids: list[int], values: list[int]) -> IMorphoBlueHyperdriveBatchTransferFromContractFunction:  # type: ignore
        clone = super().__call__(
            dataclass_to_tuple(_from), dataclass_to_tuple(to), dataclass_to_tuple(ids), dataclass_to_tuple(values)
        )
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: CallOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # Define the expected return types from the smart contract call

        # Call the function


class IMorphoBlueHyperdriveCheckpointContractFunction(ContractFunction):
    """ContractFunction for the checkpoint method."""

    def __call__(self, checkpointTime: int, maxIterations: int) -> IMorphoBlueHyperdriveCheckpointContractFunction:  # type: ignore
        clone = super().__call__(dataclass_to_tuple(checkpointTime), dataclass_to_tuple(maxIterations))
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: CallOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # Define the expected return types from the smart contract call

        # Call the function


class IMorphoBlueHyperdriveCloseLongContractFunction(ContractFunction):
    """ContractFunction for the closeLong method."""

    def __call__(self, maturityTime: int, bondAmount: int, minOutput: int, options: Options) -> IMorphoBlueHyperdriveCloseLongContractFunction:  # type: ignore
        clone = super().__call__(
            dataclass_to_tuple(maturityTime),
            dataclass_to_tuple(bondAmount),
            dataclass_to_tuple(minOutput),
            dataclass_to_tuple(options),
        )
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: CallOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # Define the expected return types from the smart contract call

        return_types = int

        # Call the function

        raw_values = super().call(transaction, block_identifier, state_override, ccip_read_enabled)
        return cast(int, rename_returned_types(structs, return_types, raw_values))


class IMorphoBlueHyperdriveCloseShortContractFunction(ContractFunction):
    """ContractFunction for the closeShort method."""

    def __call__(self, maturityTime: int, bondAmount: int, minOutput: int, options: Options) -> IMorphoBlueHyperdriveCloseShortContractFunction:  # type: ignore
        clone = super().__call__(
            dataclass_to_tuple(maturityTime),
            dataclass_to_tuple(bondAmount),
            dataclass_to_tuple(minOutput),
            dataclass_to_tuple(options),
        )
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: CallOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # Define the expected return types from the smart contract call

        return_types = int

        # Call the function

        raw_values = super().call(transaction, block_identifier, state_override, ccip_read_enabled)
        return cast(int, rename_returned_types(structs, return_types, raw_values))


class IMorphoBlueHyperdriveCollateralTokenContractFunction(ContractFunction):
    """ContractFunction for the collateralToken method."""

    def __call__(self) -> IMorphoBlueHyperdriveCollateralTokenContractFunction:  # type: ignore
        clone = super().__call__()
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: CallOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # Define the expected return types from the smart contract call

        return_types = str

        # Call the function

        raw_values = super().call(transaction, block_identifier, state_override, ccip_read_enabled)
        return cast(str, rename_returned_types(structs, return_types, raw_values))


class IMorphoBlueHyperdriveCollectGovernanceFeeContractFunction(ContractFunction):
    """ContractFunction for the collectGovernanceFee method."""

    def __call__(self, options: Options) -> IMorphoBlueHyperdriveCollectGovernanceFeeContractFunction:  # type: ignore
        clone = super().__call__(dataclass_to_tuple(options))
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: CallOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # Define the expected return types from the smart contract call

        return_types = int

        # Call the function

        raw_values = super().call(transaction, block_identifier, state_override, ccip_read_enabled)
        return cast(int, rename_returned_types(structs, return_types, raw_values))


class IMorphoBlueHyperdriveConvertToBaseContractFunction(ContractFunction):
    """ContractFunction for the convertToBase method."""

    def __call__(self, shareAmount: int) -> IMorphoBlueHyperdriveConvertToBaseContractFunction:  # type: ignore
        clone = super().__call__(dataclass_to_tuple(shareAmount))
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: CallOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # Define the expected return types from the smart contract call

        return_types = int

        # Call the function

        raw_values = super().call(transaction, block_identifier, state_override, ccip_read_enabled)
        return cast(int, rename_returned_types(structs, return_types, raw_values))


class IMorphoBlueHyperdriveConvertToSharesContractFunction(ContractFunction):
    """ContractFunction for the convertToShares method."""

    def __call__(self, baseAmount: int) -> IMorphoBlueHyperdriveConvertToSharesContractFunction:  # type: ignore
        clone = super().__call__(dataclass_to_tuple(baseAmount))
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: CallOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # Define the expected return types from the smart contract call

        return_types = int

        # Call the function

        raw_values = super().call(transaction, block_identifier, state_override, ccip_read_enabled)
        return cast(int, rename_returned_types(structs, return_types, raw_values))


class IMorphoBlueHyperdriveDecimalsContractFunction(ContractFunction):
    """ContractFunction for the decimals method."""

    def __call__(self) -> IMorphoBlueHyperdriveDecimalsContractFunction:  # type: ignore
        clone = super().__call__()
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: CallOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # Define the expected return types from the smart contract call

        return_types = int

        # Call the function

        raw_values = super().call(transaction, block_identifier, state_override, ccip_read_enabled)
        return cast(int, rename_returned_types(structs, return_types, raw_values))


class IMorphoBlueHyperdriveDomainSeparatorContractFunction(ContractFunction):
    """ContractFunction for the domainSeparator method."""

    def __call__(self) -> IMorphoBlueHyperdriveDomainSeparatorContractFunction:  # type: ignore
        clone = super().__call__()
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: CallOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bytes:
        """returns bytes."""
        # Define the expected return types from the smart contract call

        return_types = bytes

        # Call the function

        raw_values = super().call(transaction, block_identifier, state_override, ccip_read_enabled)
        return cast(bytes, rename_returned_types(structs, return_types, raw_values))


class IMorphoBlueHyperdriveGetCheckpointContractFunction(ContractFunction):
    """ContractFunction for the getCheckpoint method."""

    def __call__(self, checkpointTime: int) -> IMorphoBlueHyperdriveGetCheckpointContractFunction:  # type: ignore
        clone = super().__call__(dataclass_to_tuple(checkpointTime))
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: CallOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> Checkpoint:
        """returns Checkpoint."""
        # Define the expected return types from the smart contract call

        return_types = Checkpoint

        # Call the function

        raw_values = super().call(transaction, block_identifier, state_override, ccip_read_enabled)
        return cast(Checkpoint, rename_returned_types(structs, return_types, raw_values))


class IMorphoBlueHyperdriveGetCheckpointExposureContractFunction(ContractFunction):
    """ContractFunction for the getCheckpointExposure method."""

    def __call__(self, checkpointTime: int) -> IMorphoBlueHyperdriveGetCheckpointExposureContractFunction:  # type: ignore
        clone = super().__call__(dataclass_to_tuple(checkpointTime))
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: CallOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # Define the expected return types from the smart contract call

        return_types = int

        # Call the function

        raw_values = super().call(transaction, block_identifier, state_override, ccip_read_enabled)
        return cast(int, rename_returned_types(structs, return_types, raw_values))


class IMorphoBlueHyperdriveGetMarketStateContractFunction(ContractFunction):
    """ContractFunction for the getMarketState method."""

    def __call__(self) -> IMorphoBlueHyperdriveGetMarketStateContractFunction:  # type: ignore
        clone = super().__call__()
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: CallOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> MarketState:
        """returns MarketState."""
        # Define the expected return types from the smart contract call

        return_types = MarketState

        # Call the function

        raw_values = super().call(transaction, block_identifier, state_override, ccip_read_enabled)
        return cast(MarketState, rename_returned_types(structs, return_types, raw_values))


class IMorphoBlueHyperdriveGetPoolConfigContractFunction(ContractFunction):
    """ContractFunction for the getPoolConfig method."""

    def __call__(self) -> IMorphoBlueHyperdriveGetPoolConfigContractFunction:  # type: ignore
        clone = super().__call__()
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: CallOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> PoolConfig:
        """returns PoolConfig."""
        # Define the expected return types from the smart contract call

        return_types = PoolConfig

        # Call the function

        raw_values = super().call(transaction, block_identifier, state_override, ccip_read_enabled)
        return cast(PoolConfig, rename_returned_types(structs, return_types, raw_values))


class IMorphoBlueHyperdriveGetPoolInfoContractFunction(ContractFunction):
    """ContractFunction for the getPoolInfo method."""

    def __call__(self) -> IMorphoBlueHyperdriveGetPoolInfoContractFunction:  # type: ignore
        clone = super().__call__()
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: CallOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> PoolInfo:
        """returns PoolInfo."""
        # Define the expected return types from the smart contract call

        return_types = PoolInfo

        # Call the function

        raw_values = super().call(transaction, block_identifier, state_override, ccip_read_enabled)
        return cast(PoolInfo, rename_returned_types(structs, return_types, raw_values))


class IMorphoBlueHyperdriveGetUncollectedGovernanceFeesContractFunction(ContractFunction):
    """ContractFunction for the getUncollectedGovernanceFees method."""

    def __call__(self) -> IMorphoBlueHyperdriveGetUncollectedGovernanceFeesContractFunction:  # type: ignore
        clone = super().__call__()
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: CallOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # Define the expected return types from the smart contract call

        return_types = int

        # Call the function

        raw_values = super().call(transaction, block_identifier, state_override, ccip_read_enabled)
        return cast(int, rename_returned_types(structs, return_types, raw_values))


class IMorphoBlueHyperdriveGetWithdrawPoolContractFunction(ContractFunction):
    """ContractFunction for the getWithdrawPool method."""

    def __call__(self) -> IMorphoBlueHyperdriveGetWithdrawPoolContractFunction:  # type: ignore
        clone = super().__call__()
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: CallOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> WithdrawPool:
        """returns WithdrawPool."""
        # Define the expected return types from the smart contract call

        return_types = WithdrawPool

        # Call the function

        raw_values = super().call(transaction, block_identifier, state_override, ccip_read_enabled)
        return cast(WithdrawPool, rename_returned_types(structs, return_types, raw_values))


class IMorphoBlueHyperdriveInitializeContractFunction(ContractFunction):
    """ContractFunction for the initialize method."""

    def __call__(self, contribution: int, apr: int, options: Options) -> IMorphoBlueHyperdriveInitializeContractFunction:  # type: ignore
        clone = super().__call__(dataclass_to_tuple(contribution), dataclass_to_tuple(apr), dataclass_to_tuple(options))
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: CallOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # Define the expected return types from the smart contract call

        return_types = int

        # Call the function

        raw_values = super().call(transaction, block_identifier, state_override, ccip_read_enabled)
        return cast(int, rename_returned_types(structs, return_types, raw_values))


class IMorphoBlueHyperdriveIrmContractFunction(ContractFunction):
    """ContractFunction for the irm method."""

    def __call__(self) -> IMorphoBlueHyperdriveIrmContractFunction:  # type: ignore
        clone = super().__call__()
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: CallOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # Define the expected return types from the smart contract call

        return_types = str

        # Call the function

        raw_values = super().call(transaction, block_identifier, state_override, ccip_read_enabled)
        return cast(str, rename_returned_types(structs, return_types, raw_values))


class IMorphoBlueHyperdriveIsApprovedForAllContractFunction(ContractFunction):
    """ContractFunction for the isApprovedForAll method."""

    def __call__(self, owner: str, spender: str) -> IMorphoBlueHyperdriveIsApprovedForAllContractFunction:  # type: ignore
        clone = super().__call__(dataclass_to_tuple(owner), dataclass_to_tuple(spender))
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: CallOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bool:
        """returns bool."""
        # Define the expected return types from the smart contract call

        return_types = bool

        # Call the function

        raw_values = super().call(transaction, block_identifier, state_override, ccip_read_enabled)
        return cast(bool, rename_returned_types(structs, return_types, raw_values))


class IMorphoBlueHyperdriveIsPauserContractFunction(ContractFunction):
    """ContractFunction for the isPauser method."""

    def __call__(self, account: str) -> IMorphoBlueHyperdriveIsPauserContractFunction:  # type: ignore
        clone = super().__call__(dataclass_to_tuple(account))
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: CallOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bool:
        """returns bool."""
        # Define the expected return types from the smart contract call

        return_types = bool

        # Call the function

        raw_values = super().call(transaction, block_identifier, state_override, ccip_read_enabled)
        return cast(bool, rename_returned_types(structs, return_types, raw_values))


class IMorphoBlueHyperdriveKindContractFunction(ContractFunction):
    """ContractFunction for the kind method."""

    def __call__(self) -> IMorphoBlueHyperdriveKindContractFunction:  # type: ignore
        clone = super().__call__()
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: CallOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # Define the expected return types from the smart contract call

        return_types = str

        # Call the function

        raw_values = super().call(transaction, block_identifier, state_override, ccip_read_enabled)
        return cast(str, rename_returned_types(structs, return_types, raw_values))


class IMorphoBlueHyperdriveLltvContractFunction(ContractFunction):
    """ContractFunction for the lltv method."""

    def __call__(self) -> IMorphoBlueHyperdriveLltvContractFunction:  # type: ignore
        clone = super().__call__()
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: CallOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # Define the expected return types from the smart contract call

        return_types = int

        # Call the function

        raw_values = super().call(transaction, block_identifier, state_override, ccip_read_enabled)
        return cast(int, rename_returned_types(structs, return_types, raw_values))


class IMorphoBlueHyperdriveLoadContractFunction(ContractFunction):
    """ContractFunction for the load method."""

    def __call__(self, slots: list[int]) -> IMorphoBlueHyperdriveLoadContractFunction:  # type: ignore
        clone = super().__call__(dataclass_to_tuple(slots))
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: CallOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[bytes]:
        """returns list[bytes]."""
        # Define the expected return types from the smart contract call

        return_types = list[bytes]

        # Call the function

        raw_values = super().call(transaction, block_identifier, state_override, ccip_read_enabled)
        return cast(list[bytes], rename_returned_types(structs, return_types, raw_values))


class IMorphoBlueHyperdriveNameContractFunction0(ContractFunction):
    """ContractFunction for the name method."""

    def __call__(self, tokenId: int) -> IMorphoBlueHyperdriveNameContractFunction:  # type: ignore
        super().__call__()  # type: ignore
        return cast(IMorphoBlueHyperdriveNameContractFunction, self)

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: CallOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # Define the expected return types from the smart contract call

        return_types = str

        # Call the function
        raw_values = super().call(transaction, block_identifier, state_override, ccip_read_enabled)

        return cast(str, rename_returned_types(structs, return_types, raw_values))


class IMorphoBlueHyperdriveNameContractFunction1(ContractFunction):
    """ContractFunction for the name method."""

    def __call__(self) -> IMorphoBlueHyperdriveNameContractFunction:  # type: ignore
        super().__call__()  # type: ignore
        return cast(IMorphoBlueHyperdriveNameContractFunction, self)

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: CallOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # Define the expected return types from the smart contract call

        return_types = str

        # Call the function
        raw_values = super().call(transaction, block_identifier, state_override, ccip_read_enabled)

        return cast(str, rename_returned_types(structs, return_types, raw_values))


class IMorphoBlueHyperdriveNameContractFunction(ContractFunction):
    """ContractFunction for the name method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    @overload
    def __call__(self, tokenId: int) -> IMorphoBlueHyperdriveNameContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self) -> IMorphoBlueHyperdriveNameContractFunction1:  # type: ignore
        ...

    def __call__(self, *args) -> IMorphoBlueHyperdriveNameContractFunction:  # type: ignore
        clone = super().__call__(*(dataclass_to_tuple(arg) for arg in args))
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self  # type: ignore


class IMorphoBlueHyperdriveNoncesContractFunction(ContractFunction):
    """ContractFunction for the nonces method."""

    def __call__(self, owner: str) -> IMorphoBlueHyperdriveNoncesContractFunction:  # type: ignore
        clone = super().__call__(dataclass_to_tuple(owner))
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: CallOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # Define the expected return types from the smart contract call

        return_types = int

        # Call the function

        raw_values = super().call(transaction, block_identifier, state_override, ccip_read_enabled)
        return cast(int, rename_returned_types(structs, return_types, raw_values))


class IMorphoBlueHyperdriveOpenLongContractFunction(ContractFunction):
    """ContractFunction for the openLong method."""

    class ReturnValues(NamedTuple):
        """The return named tuple for OpenLong."""

        maturityTime: int
        bondProceeds: int

    def __call__(self, amount: int, minOutput: int, minVaultSharePrice: int, options: Options) -> IMorphoBlueHyperdriveOpenLongContractFunction:  # type: ignore
        clone = super().__call__(
            dataclass_to_tuple(amount),
            dataclass_to_tuple(minOutput),
            dataclass_to_tuple(minVaultSharePrice),
            dataclass_to_tuple(options),
        )
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: CallOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> ReturnValues:
        """returns ReturnValues."""
        # Define the expected return types from the smart contract call

        return_types = [int, int]

        # Call the function

        raw_values = super().call(transaction, block_identifier, state_override, ccip_read_enabled)
        return self.ReturnValues(*rename_returned_types(structs, return_types, raw_values))


class IMorphoBlueHyperdriveOpenShortContractFunction(ContractFunction):
    """ContractFunction for the openShort method."""

    class ReturnValues(NamedTuple):
        """The return named tuple for OpenShort."""

        maturityTime: int
        deposit: int

    def __call__(self, bondAmount: int, maxDeposit: int, minVaultSharePrice: int, options: Options) -> IMorphoBlueHyperdriveOpenShortContractFunction:  # type: ignore
        clone = super().__call__(
            dataclass_to_tuple(bondAmount),
            dataclass_to_tuple(maxDeposit),
            dataclass_to_tuple(minVaultSharePrice),
            dataclass_to_tuple(options),
        )
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: CallOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> ReturnValues:
        """returns ReturnValues."""
        # Define the expected return types from the smart contract call

        return_types = [int, int]

        # Call the function

        raw_values = super().call(transaction, block_identifier, state_override, ccip_read_enabled)
        return self.ReturnValues(*rename_returned_types(structs, return_types, raw_values))


class IMorphoBlueHyperdriveOracleContractFunction(ContractFunction):
    """ContractFunction for the oracle method."""

    def __call__(self) -> IMorphoBlueHyperdriveOracleContractFunction:  # type: ignore
        clone = super().__call__()
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: CallOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # Define the expected return types from the smart contract call

        return_types = str

        # Call the function

        raw_values = super().call(transaction, block_identifier, state_override, ccip_read_enabled)
        return cast(str, rename_returned_types(structs, return_types, raw_values))


class IMorphoBlueHyperdrivePauseContractFunction(ContractFunction):
    """ContractFunction for the pause method."""

    def __call__(self, status: bool) -> IMorphoBlueHyperdrivePauseContractFunction:  # type: ignore
        clone = super().__call__(dataclass_to_tuple(status))
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: CallOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # Define the expected return types from the smart contract call

        # Call the function


class IMorphoBlueHyperdrivePerTokenApprovalsContractFunction(ContractFunction):
    """ContractFunction for the perTokenApprovals method."""

    def __call__(self, tokenId: int, owner: str, spender: str) -> IMorphoBlueHyperdrivePerTokenApprovalsContractFunction:  # type: ignore
        clone = super().__call__(dataclass_to_tuple(tokenId), dataclass_to_tuple(owner), dataclass_to_tuple(spender))
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: CallOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # Define the expected return types from the smart contract call

        return_types = int

        # Call the function

        raw_values = super().call(transaction, block_identifier, state_override, ccip_read_enabled)
        return cast(int, rename_returned_types(structs, return_types, raw_values))


class IMorphoBlueHyperdrivePermitForAllContractFunction(ContractFunction):
    """ContractFunction for the permitForAll method."""

    def __call__(self, owner: str, spender: str, approved: bool, deadline: int, v: int, r: bytes, s: bytes) -> IMorphoBlueHyperdrivePermitForAllContractFunction:  # type: ignore
        clone = super().__call__(
            dataclass_to_tuple(owner),
            dataclass_to_tuple(spender),
            dataclass_to_tuple(approved),
            dataclass_to_tuple(deadline),
            dataclass_to_tuple(v),
            dataclass_to_tuple(r),
            dataclass_to_tuple(s),
        )
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: CallOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # Define the expected return types from the smart contract call

        # Call the function


class IMorphoBlueHyperdriveRedeemWithdrawalSharesContractFunction(ContractFunction):
    """ContractFunction for the redeemWithdrawalShares method."""

    class ReturnValues(NamedTuple):
        """The return named tuple for RedeemWithdrawalShares."""

        proceeds: int
        withdrawalSharesRedeemed: int

    def __call__(self, withdrawalShares: int, minOutputPerShare: int, options: Options) -> IMorphoBlueHyperdriveRedeemWithdrawalSharesContractFunction:  # type: ignore
        clone = super().__call__(
            dataclass_to_tuple(withdrawalShares), dataclass_to_tuple(minOutputPerShare), dataclass_to_tuple(options)
        )
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: CallOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> ReturnValues:
        """returns ReturnValues."""
        # Define the expected return types from the smart contract call

        return_types = [int, int]

        # Call the function

        raw_values = super().call(transaction, block_identifier, state_override, ccip_read_enabled)
        return self.ReturnValues(*rename_returned_types(structs, return_types, raw_values))


class IMorphoBlueHyperdriveRemoveLiquidityContractFunction(ContractFunction):
    """ContractFunction for the removeLiquidity method."""

    class ReturnValues(NamedTuple):
        """The return named tuple for RemoveLiquidity."""

        proceeds: int
        withdrawalShares: int

    def __call__(self, lpShares: int, minOutputPerShare: int, options: Options) -> IMorphoBlueHyperdriveRemoveLiquidityContractFunction:  # type: ignore
        clone = super().__call__(
            dataclass_to_tuple(lpShares), dataclass_to_tuple(minOutputPerShare), dataclass_to_tuple(options)
        )
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: CallOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> ReturnValues:
        """returns ReturnValues."""
        # Define the expected return types from the smart contract call

        return_types = [int, int]

        # Call the function

        raw_values = super().call(transaction, block_identifier, state_override, ccip_read_enabled)
        return self.ReturnValues(*rename_returned_types(structs, return_types, raw_values))


class IMorphoBlueHyperdriveSetApprovalContractFunction(ContractFunction):
    """ContractFunction for the setApproval method."""

    def __call__(self, tokenID: int, operator: str, amount: int) -> IMorphoBlueHyperdriveSetApprovalContractFunction:  # type: ignore
        clone = super().__call__(dataclass_to_tuple(tokenID), dataclass_to_tuple(operator), dataclass_to_tuple(amount))
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: CallOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # Define the expected return types from the smart contract call

        # Call the function


class IMorphoBlueHyperdriveSetApprovalBridgeContractFunction(ContractFunction):
    """ContractFunction for the setApprovalBridge method."""

    def __call__(self, tokenID: int, operator: str, amount: int, caller: str) -> IMorphoBlueHyperdriveSetApprovalBridgeContractFunction:  # type: ignore
        clone = super().__call__(
            dataclass_to_tuple(tokenID),
            dataclass_to_tuple(operator),
            dataclass_to_tuple(amount),
            dataclass_to_tuple(caller),
        )
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: CallOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # Define the expected return types from the smart contract call

        # Call the function


class IMorphoBlueHyperdriveSetApprovalForAllContractFunction(ContractFunction):
    """ContractFunction for the setApprovalForAll method."""

    def __call__(self, operator: str, approved: bool) -> IMorphoBlueHyperdriveSetApprovalForAllContractFunction:  # type: ignore
        clone = super().__call__(dataclass_to_tuple(operator), dataclass_to_tuple(approved))
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: CallOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # Define the expected return types from the smart contract call

        # Call the function


class IMorphoBlueHyperdriveSetCheckpointRewarderContractFunction(ContractFunction):
    """ContractFunction for the setCheckpointRewarder method."""

    def __call__(self, checkpointRewarder: str) -> IMorphoBlueHyperdriveSetCheckpointRewarderContractFunction:  # type: ignore
        clone = super().__call__(dataclass_to_tuple(checkpointRewarder))
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: CallOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # Define the expected return types from the smart contract call

        # Call the function


class IMorphoBlueHyperdriveSetFeeCollectorContractFunction(ContractFunction):
    """ContractFunction for the setFeeCollector method."""

    def __call__(self, who: str) -> IMorphoBlueHyperdriveSetFeeCollectorContractFunction:  # type: ignore
        clone = super().__call__(dataclass_to_tuple(who))
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: CallOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # Define the expected return types from the smart contract call

        # Call the function


class IMorphoBlueHyperdriveSetGovernanceContractFunction(ContractFunction):
    """ContractFunction for the setGovernance method."""

    def __call__(self, who: str) -> IMorphoBlueHyperdriveSetGovernanceContractFunction:  # type: ignore
        clone = super().__call__(dataclass_to_tuple(who))
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: CallOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # Define the expected return types from the smart contract call

        # Call the function


class IMorphoBlueHyperdriveSetPauserContractFunction(ContractFunction):
    """ContractFunction for the setPauser method."""

    def __call__(self, who: str, status: bool) -> IMorphoBlueHyperdriveSetPauserContractFunction:  # type: ignore
        clone = super().__call__(dataclass_to_tuple(who), dataclass_to_tuple(status))
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: CallOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # Define the expected return types from the smart contract call

        # Call the function


class IMorphoBlueHyperdriveSetSweepCollectorContractFunction(ContractFunction):
    """ContractFunction for the setSweepCollector method."""

    def __call__(self, who: str) -> IMorphoBlueHyperdriveSetSweepCollectorContractFunction:  # type: ignore
        clone = super().__call__(dataclass_to_tuple(who))
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: CallOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # Define the expected return types from the smart contract call

        # Call the function


class IMorphoBlueHyperdriveSweepContractFunction(ContractFunction):
    """ContractFunction for the sweep method."""

    def __call__(self, target: str) -> IMorphoBlueHyperdriveSweepContractFunction:  # type: ignore
        clone = super().__call__(dataclass_to_tuple(target))
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: CallOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # Define the expected return types from the smart contract call

        # Call the function


class IMorphoBlueHyperdriveSymbolContractFunction(ContractFunction):
    """ContractFunction for the symbol method."""

    def __call__(self, tokenId: int) -> IMorphoBlueHyperdriveSymbolContractFunction:  # type: ignore
        clone = super().__call__(dataclass_to_tuple(tokenId))
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: CallOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # Define the expected return types from the smart contract call

        return_types = str

        # Call the function

        raw_values = super().call(transaction, block_identifier, state_override, ccip_read_enabled)
        return cast(str, rename_returned_types(structs, return_types, raw_values))


class IMorphoBlueHyperdriveTarget0ContractFunction(ContractFunction):
    """ContractFunction for the target0 method."""

    def __call__(self) -> IMorphoBlueHyperdriveTarget0ContractFunction:  # type: ignore
        clone = super().__call__()
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: CallOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # Define the expected return types from the smart contract call

        return_types = str

        # Call the function

        raw_values = super().call(transaction, block_identifier, state_override, ccip_read_enabled)
        return cast(str, rename_returned_types(structs, return_types, raw_values))


class IMorphoBlueHyperdriveTarget1ContractFunction(ContractFunction):
    """ContractFunction for the target1 method."""

    def __call__(self) -> IMorphoBlueHyperdriveTarget1ContractFunction:  # type: ignore
        clone = super().__call__()
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: CallOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # Define the expected return types from the smart contract call

        return_types = str

        # Call the function

        raw_values = super().call(transaction, block_identifier, state_override, ccip_read_enabled)
        return cast(str, rename_returned_types(structs, return_types, raw_values))


class IMorphoBlueHyperdriveTarget2ContractFunction(ContractFunction):
    """ContractFunction for the target2 method."""

    def __call__(self) -> IMorphoBlueHyperdriveTarget2ContractFunction:  # type: ignore
        clone = super().__call__()
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: CallOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # Define the expected return types from the smart contract call

        return_types = str

        # Call the function

        raw_values = super().call(transaction, block_identifier, state_override, ccip_read_enabled)
        return cast(str, rename_returned_types(structs, return_types, raw_values))


class IMorphoBlueHyperdriveTarget3ContractFunction(ContractFunction):
    """ContractFunction for the target3 method."""

    def __call__(self) -> IMorphoBlueHyperdriveTarget3ContractFunction:  # type: ignore
        clone = super().__call__()
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: CallOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # Define the expected return types from the smart contract call

        return_types = str

        # Call the function

        raw_values = super().call(transaction, block_identifier, state_override, ccip_read_enabled)
        return cast(str, rename_returned_types(structs, return_types, raw_values))


class IMorphoBlueHyperdriveTarget4ContractFunction(ContractFunction):
    """ContractFunction for the target4 method."""

    def __call__(self) -> IMorphoBlueHyperdriveTarget4ContractFunction:  # type: ignore
        clone = super().__call__()
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: CallOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # Define the expected return types from the smart contract call

        return_types = str

        # Call the function

        raw_values = super().call(transaction, block_identifier, state_override, ccip_read_enabled)
        return cast(str, rename_returned_types(structs, return_types, raw_values))


class IMorphoBlueHyperdriveTotalSupplyContractFunction(ContractFunction):
    """ContractFunction for the totalSupply method."""

    def __call__(self, tokenId: int) -> IMorphoBlueHyperdriveTotalSupplyContractFunction:  # type: ignore
        clone = super().__call__(dataclass_to_tuple(tokenId))
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: CallOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # Define the expected return types from the smart contract call

        return_types = int

        # Call the function

        raw_values = super().call(transaction, block_identifier, state_override, ccip_read_enabled)
        return cast(int, rename_returned_types(structs, return_types, raw_values))


class IMorphoBlueHyperdriveTransferFromContractFunction(ContractFunction):
    """ContractFunction for the transferFrom method."""

    def __call__(self, tokenID: int, _from: str, to: str, amount: int) -> IMorphoBlueHyperdriveTransferFromContractFunction:  # type: ignore
        clone = super().__call__(
            dataclass_to_tuple(tokenID), dataclass_to_tuple(_from), dataclass_to_tuple(to), dataclass_to_tuple(amount)
        )
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: CallOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # Define the expected return types from the smart contract call

        # Call the function


class IMorphoBlueHyperdriveTransferFromBridgeContractFunction(ContractFunction):
    """ContractFunction for the transferFromBridge method."""

    def __call__(self, tokenID: int, _from: str, to: str, amount: int, caller: str) -> IMorphoBlueHyperdriveTransferFromBridgeContractFunction:  # type: ignore
        clone = super().__call__(
            dataclass_to_tuple(tokenID),
            dataclass_to_tuple(_from),
            dataclass_to_tuple(to),
            dataclass_to_tuple(amount),
            dataclass_to_tuple(caller),
        )
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: CallOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # Define the expected return types from the smart contract call

        # Call the function


class IMorphoBlueHyperdriveVaultContractFunction(ContractFunction):
    """ContractFunction for the vault method."""

    def __call__(self) -> IMorphoBlueHyperdriveVaultContractFunction:  # type: ignore
        clone = super().__call__()
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: CallOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # Define the expected return types from the smart contract call

        return_types = str

        # Call the function

        raw_values = super().call(transaction, block_identifier, state_override, ccip_read_enabled)
        return cast(str, rename_returned_types(structs, return_types, raw_values))


class IMorphoBlueHyperdriveVaultSharesTokenContractFunction(ContractFunction):
    """ContractFunction for the vaultSharesToken method."""

    def __call__(self) -> IMorphoBlueHyperdriveVaultSharesTokenContractFunction:  # type: ignore
        clone = super().__call__()
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: CallOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # Define the expected return types from the smart contract call

        return_types = str

        # Call the function

        raw_values = super().call(transaction, block_identifier, state_override, ccip_read_enabled)
        return cast(str, rename_returned_types(structs, return_types, raw_values))


class IMorphoBlueHyperdriveVersionContractFunction(ContractFunction):
    """ContractFunction for the version method."""

    def __call__(self) -> IMorphoBlueHyperdriveVersionContractFunction:  # type: ignore
        clone = super().__call__()
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: CallOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # Define the expected return types from the smart contract call

        return_types = str

        # Call the function

        raw_values = super().call(transaction, block_identifier, state_override, ccip_read_enabled)
        return cast(str, rename_returned_types(structs, return_types, raw_values))


class IMorphoBlueHyperdriveContractFunctions(ContractFunctions):
    """ContractFunctions for the IMorphoBlueHyperdrive contract."""

    PERMIT_TYPEHASH: IMorphoBlueHyperdrivePERMIT_TYPEHASHContractFunction

    addLiquidity: IMorphoBlueHyperdriveAddLiquidityContractFunction

    balanceOf: IMorphoBlueHyperdriveBalanceOfContractFunction

    baseToken: IMorphoBlueHyperdriveBaseTokenContractFunction

    batchTransferFrom: IMorphoBlueHyperdriveBatchTransferFromContractFunction

    checkpoint: IMorphoBlueHyperdriveCheckpointContractFunction

    closeLong: IMorphoBlueHyperdriveCloseLongContractFunction

    closeShort: IMorphoBlueHyperdriveCloseShortContractFunction

    collateralToken: IMorphoBlueHyperdriveCollateralTokenContractFunction

    collectGovernanceFee: IMorphoBlueHyperdriveCollectGovernanceFeeContractFunction

    convertToBase: IMorphoBlueHyperdriveConvertToBaseContractFunction

    convertToShares: IMorphoBlueHyperdriveConvertToSharesContractFunction

    decimals: IMorphoBlueHyperdriveDecimalsContractFunction

    domainSeparator: IMorphoBlueHyperdriveDomainSeparatorContractFunction

    getCheckpoint: IMorphoBlueHyperdriveGetCheckpointContractFunction

    getCheckpointExposure: IMorphoBlueHyperdriveGetCheckpointExposureContractFunction

    getMarketState: IMorphoBlueHyperdriveGetMarketStateContractFunction

    getPoolConfig: IMorphoBlueHyperdriveGetPoolConfigContractFunction

    getPoolInfo: IMorphoBlueHyperdriveGetPoolInfoContractFunction

    getUncollectedGovernanceFees: IMorphoBlueHyperdriveGetUncollectedGovernanceFeesContractFunction

    getWithdrawPool: IMorphoBlueHyperdriveGetWithdrawPoolContractFunction

    initialize: IMorphoBlueHyperdriveInitializeContractFunction

    irm: IMorphoBlueHyperdriveIrmContractFunction

    isApprovedForAll: IMorphoBlueHyperdriveIsApprovedForAllContractFunction

    isPauser: IMorphoBlueHyperdriveIsPauserContractFunction

    kind: IMorphoBlueHyperdriveKindContractFunction

    lltv: IMorphoBlueHyperdriveLltvContractFunction

    load: IMorphoBlueHyperdriveLoadContractFunction

    name: IMorphoBlueHyperdriveNameContractFunction

    nonces: IMorphoBlueHyperdriveNoncesContractFunction

    openLong: IMorphoBlueHyperdriveOpenLongContractFunction

    openShort: IMorphoBlueHyperdriveOpenShortContractFunction

    oracle: IMorphoBlueHyperdriveOracleContractFunction

    pause: IMorphoBlueHyperdrivePauseContractFunction

    perTokenApprovals: IMorphoBlueHyperdrivePerTokenApprovalsContractFunction

    permitForAll: IMorphoBlueHyperdrivePermitForAllContractFunction

    redeemWithdrawalShares: IMorphoBlueHyperdriveRedeemWithdrawalSharesContractFunction

    removeLiquidity: IMorphoBlueHyperdriveRemoveLiquidityContractFunction

    setApproval: IMorphoBlueHyperdriveSetApprovalContractFunction

    setApprovalBridge: IMorphoBlueHyperdriveSetApprovalBridgeContractFunction

    setApprovalForAll: IMorphoBlueHyperdriveSetApprovalForAllContractFunction

    setCheckpointRewarder: IMorphoBlueHyperdriveSetCheckpointRewarderContractFunction

    setFeeCollector: IMorphoBlueHyperdriveSetFeeCollectorContractFunction

    setGovernance: IMorphoBlueHyperdriveSetGovernanceContractFunction

    setPauser: IMorphoBlueHyperdriveSetPauserContractFunction

    setSweepCollector: IMorphoBlueHyperdriveSetSweepCollectorContractFunction

    sweep: IMorphoBlueHyperdriveSweepContractFunction

    symbol: IMorphoBlueHyperdriveSymbolContractFunction

    target0: IMorphoBlueHyperdriveTarget0ContractFunction

    target1: IMorphoBlueHyperdriveTarget1ContractFunction

    target2: IMorphoBlueHyperdriveTarget2ContractFunction

    target3: IMorphoBlueHyperdriveTarget3ContractFunction

    target4: IMorphoBlueHyperdriveTarget4ContractFunction

    totalSupply: IMorphoBlueHyperdriveTotalSupplyContractFunction

    transferFrom: IMorphoBlueHyperdriveTransferFromContractFunction

    transferFromBridge: IMorphoBlueHyperdriveTransferFromBridgeContractFunction

    vault: IMorphoBlueHyperdriveVaultContractFunction

    vaultSharesToken: IMorphoBlueHyperdriveVaultSharesTokenContractFunction

    version: IMorphoBlueHyperdriveVersionContractFunction

    def __init__(
        self,
        abi: ABI,
        w3: "Web3",
        address: ChecksumAddress | None = None,
        decode_tuples: bool | None = False,
    ) -> None:
        super().__init__(abi, w3, address, decode_tuples)
        self.PERMIT_TYPEHASH = IMorphoBlueHyperdrivePERMIT_TYPEHASHContractFunction.factory(
            "PERMIT_TYPEHASH",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            function_identifier="PERMIT_TYPEHASH",
        )
        self.addLiquidity = IMorphoBlueHyperdriveAddLiquidityContractFunction.factory(
            "addLiquidity",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            function_identifier="addLiquidity",
        )
        self.balanceOf = IMorphoBlueHyperdriveBalanceOfContractFunction.factory(
            "balanceOf",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            function_identifier="balanceOf",
        )
        self.baseToken = IMorphoBlueHyperdriveBaseTokenContractFunction.factory(
            "baseToken",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            function_identifier="baseToken",
        )
        self.batchTransferFrom = IMorphoBlueHyperdriveBatchTransferFromContractFunction.factory(
            "batchTransferFrom",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            function_identifier="batchTransferFrom",
        )
        self.checkpoint = IMorphoBlueHyperdriveCheckpointContractFunction.factory(
            "checkpoint",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            function_identifier="checkpoint",
        )
        self.closeLong = IMorphoBlueHyperdriveCloseLongContractFunction.factory(
            "closeLong",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            function_identifier="closeLong",
        )
        self.closeShort = IMorphoBlueHyperdriveCloseShortContractFunction.factory(
            "closeShort",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            function_identifier="closeShort",
        )
        self.collateralToken = IMorphoBlueHyperdriveCollateralTokenContractFunction.factory(
            "collateralToken",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            function_identifier="collateralToken",
        )
        self.collectGovernanceFee = IMorphoBlueHyperdriveCollectGovernanceFeeContractFunction.factory(
            "collectGovernanceFee",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            function_identifier="collectGovernanceFee",
        )
        self.convertToBase = IMorphoBlueHyperdriveConvertToBaseContractFunction.factory(
            "convertToBase",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            function_identifier="convertToBase",
        )
        self.convertToShares = IMorphoBlueHyperdriveConvertToSharesContractFunction.factory(
            "convertToShares",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            function_identifier="convertToShares",
        )
        self.decimals = IMorphoBlueHyperdriveDecimalsContractFunction.factory(
            "decimals",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            function_identifier="decimals",
        )
        self.domainSeparator = IMorphoBlueHyperdriveDomainSeparatorContractFunction.factory(
            "domainSeparator",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            function_identifier="domainSeparator",
        )
        self.getCheckpoint = IMorphoBlueHyperdriveGetCheckpointContractFunction.factory(
            "getCheckpoint",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            function_identifier="getCheckpoint",
        )
        self.getCheckpointExposure = IMorphoBlueHyperdriveGetCheckpointExposureContractFunction.factory(
            "getCheckpointExposure",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            function_identifier="getCheckpointExposure",
        )
        self.getMarketState = IMorphoBlueHyperdriveGetMarketStateContractFunction.factory(
            "getMarketState",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            function_identifier="getMarketState",
        )
        self.getPoolConfig = IMorphoBlueHyperdriveGetPoolConfigContractFunction.factory(
            "getPoolConfig",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            function_identifier="getPoolConfig",
        )
        self.getPoolInfo = IMorphoBlueHyperdriveGetPoolInfoContractFunction.factory(
            "getPoolInfo",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            function_identifier="getPoolInfo",
        )
        self.getUncollectedGovernanceFees = IMorphoBlueHyperdriveGetUncollectedGovernanceFeesContractFunction.factory(
            "getUncollectedGovernanceFees",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            function_identifier="getUncollectedGovernanceFees",
        )
        self.getWithdrawPool = IMorphoBlueHyperdriveGetWithdrawPoolContractFunction.factory(
            "getWithdrawPool",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            function_identifier="getWithdrawPool",
        )
        self.initialize = IMorphoBlueHyperdriveInitializeContractFunction.factory(
            "initialize",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            function_identifier="initialize",
        )
        self.irm = IMorphoBlueHyperdriveIrmContractFunction.factory(
            "irm",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            function_identifier="irm",
        )
        self.isApprovedForAll = IMorphoBlueHyperdriveIsApprovedForAllContractFunction.factory(
            "isApprovedForAll",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            function_identifier="isApprovedForAll",
        )
        self.isPauser = IMorphoBlueHyperdriveIsPauserContractFunction.factory(
            "isPauser",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            function_identifier="isPauser",
        )
        self.kind = IMorphoBlueHyperdriveKindContractFunction.factory(
            "kind",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            function_identifier="kind",
        )
        self.lltv = IMorphoBlueHyperdriveLltvContractFunction.factory(
            "lltv",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            function_identifier="lltv",
        )
        self.load = IMorphoBlueHyperdriveLoadContractFunction.factory(
            "load",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            function_identifier="load",
        )
        self.name = IMorphoBlueHyperdriveNameContractFunction.factory(
            "name",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            function_identifier="name",
        )
        self.nonces = IMorphoBlueHyperdriveNoncesContractFunction.factory(
            "nonces",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            function_identifier="nonces",
        )
        self.openLong = IMorphoBlueHyperdriveOpenLongContractFunction.factory(
            "openLong",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            function_identifier="openLong",
        )
        self.openShort = IMorphoBlueHyperdriveOpenShortContractFunction.factory(
            "openShort",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            function_identifier="openShort",
        )
        self.oracle = IMorphoBlueHyperdriveOracleContractFunction.factory(
            "oracle",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            function_identifier="oracle",
        )
        self.pause = IMorphoBlueHyperdrivePauseContractFunction.factory(
            "pause",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            function_identifier="pause",
        )
        self.perTokenApprovals = IMorphoBlueHyperdrivePerTokenApprovalsContractFunction.factory(
            "perTokenApprovals",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            function_identifier="perTokenApprovals",
        )
        self.permitForAll = IMorphoBlueHyperdrivePermitForAllContractFunction.factory(
            "permitForAll",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            function_identifier="permitForAll",
        )
        self.redeemWithdrawalShares = IMorphoBlueHyperdriveRedeemWithdrawalSharesContractFunction.factory(
            "redeemWithdrawalShares",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            function_identifier="redeemWithdrawalShares",
        )
        self.removeLiquidity = IMorphoBlueHyperdriveRemoveLiquidityContractFunction.factory(
            "removeLiquidity",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            function_identifier="removeLiquidity",
        )
        self.setApproval = IMorphoBlueHyperdriveSetApprovalContractFunction.factory(
            "setApproval",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            function_identifier="setApproval",
        )
        self.setApprovalBridge = IMorphoBlueHyperdriveSetApprovalBridgeContractFunction.factory(
            "setApprovalBridge",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            function_identifier="setApprovalBridge",
        )
        self.setApprovalForAll = IMorphoBlueHyperdriveSetApprovalForAllContractFunction.factory(
            "setApprovalForAll",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            function_identifier="setApprovalForAll",
        )
        self.setCheckpointRewarder = IMorphoBlueHyperdriveSetCheckpointRewarderContractFunction.factory(
            "setCheckpointRewarder",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            function_identifier="setCheckpointRewarder",
        )
        self.setFeeCollector = IMorphoBlueHyperdriveSetFeeCollectorContractFunction.factory(
            "setFeeCollector",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            function_identifier="setFeeCollector",
        )
        self.setGovernance = IMorphoBlueHyperdriveSetGovernanceContractFunction.factory(
            "setGovernance",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            function_identifier="setGovernance",
        )
        self.setPauser = IMorphoBlueHyperdriveSetPauserContractFunction.factory(
            "setPauser",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            function_identifier="setPauser",
        )
        self.setSweepCollector = IMorphoBlueHyperdriveSetSweepCollectorContractFunction.factory(
            "setSweepCollector",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            function_identifier="setSweepCollector",
        )
        self.sweep = IMorphoBlueHyperdriveSweepContractFunction.factory(
            "sweep",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            function_identifier="sweep",
        )
        self.symbol = IMorphoBlueHyperdriveSymbolContractFunction.factory(
            "symbol",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            function_identifier="symbol",
        )
        self.target0 = IMorphoBlueHyperdriveTarget0ContractFunction.factory(
            "target0",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            function_identifier="target0",
        )
        self.target1 = IMorphoBlueHyperdriveTarget1ContractFunction.factory(
            "target1",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            function_identifier="target1",
        )
        self.target2 = IMorphoBlueHyperdriveTarget2ContractFunction.factory(
            "target2",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            function_identifier="target2",
        )
        self.target3 = IMorphoBlueHyperdriveTarget3ContractFunction.factory(
            "target3",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            function_identifier="target3",
        )
        self.target4 = IMorphoBlueHyperdriveTarget4ContractFunction.factory(
            "target4",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            function_identifier="target4",
        )
        self.totalSupply = IMorphoBlueHyperdriveTotalSupplyContractFunction.factory(
            "totalSupply",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            function_identifier="totalSupply",
        )
        self.transferFrom = IMorphoBlueHyperdriveTransferFromContractFunction.factory(
            "transferFrom",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            function_identifier="transferFrom",
        )
        self.transferFromBridge = IMorphoBlueHyperdriveTransferFromBridgeContractFunction.factory(
            "transferFromBridge",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            function_identifier="transferFromBridge",
        )
        self.vault = IMorphoBlueHyperdriveVaultContractFunction.factory(
            "vault",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            function_identifier="vault",
        )
        self.vaultSharesToken = IMorphoBlueHyperdriveVaultSharesTokenContractFunction.factory(
            "vaultSharesToken",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            function_identifier="vaultSharesToken",
        )
        self.version = IMorphoBlueHyperdriveVersionContractFunction.factory(
            "version",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            function_identifier="version",
        )


class IMorphoBlueHyperdriveAddLiquidityContractEvent(ContractEvent):
    """ContractEvent for AddLiquidity."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # @combomethod destroys return types, so we are redefining functions as both class and instance
    # pylint: disable=function-redefined

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    def get_logs(  # type: ignore
        self: "IMorphoBlueHyperdriveAddLiquidityContractEvent",
        argument_filters: dict[str, Any] | None = None,
        fromBlock: BlockIdentifier | None = None,
        toBlock: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[EventData]:
        return cast(
            Iterable[EventData],
            super().get_logs(
                argument_filters=argument_filters, fromBlock=fromBlock, toBlock=toBlock, block_hash=block_hash
            ),
        )

    @classmethod
    def get_logs(  # type: ignore
        cls: Type["IMorphoBlueHyperdriveAddLiquidityContractEvent"],
        argument_filters: dict[str, Any] | None = None,
        fromBlock: BlockIdentifier | None = None,
        toBlock: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[EventData]:
        return cast(
            Iterable[EventData],
            super().get_logs(
                argument_filters=argument_filters, fromBlock=fromBlock, toBlock=toBlock, block_hash=block_hash
            ),
        )

    def create_filter(  # type: ignore
        self: "IMorphoBlueHyperdriveAddLiquidityContractEvent",
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        fromBlock: BlockIdentifier | None = None,
        toBlock: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters, fromBlock=fromBlock, toBlock=toBlock, address=address, topics=topics
            ),
        )

    @classmethod
    def create_filter(  # type: ignore
        cls: Type["IMorphoBlueHyperdriveAddLiquidityContractEvent"],
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        fromBlock: BlockIdentifier | None = None,
        toBlock: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters, fromBlock=fromBlock, toBlock=toBlock, address=address, topics=topics
            ),
        )


class IMorphoBlueHyperdriveApprovalContractEvent(ContractEvent):
    """ContractEvent for Approval."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # @combomethod destroys return types, so we are redefining functions as both class and instance
    # pylint: disable=function-redefined

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    def get_logs(  # type: ignore
        self: "IMorphoBlueHyperdriveApprovalContractEvent",
        argument_filters: dict[str, Any] | None = None,
        fromBlock: BlockIdentifier | None = None,
        toBlock: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[EventData]:
        return cast(
            Iterable[EventData],
            super().get_logs(
                argument_filters=argument_filters, fromBlock=fromBlock, toBlock=toBlock, block_hash=block_hash
            ),
        )

    @classmethod
    def get_logs(  # type: ignore
        cls: Type["IMorphoBlueHyperdriveApprovalContractEvent"],
        argument_filters: dict[str, Any] | None = None,
        fromBlock: BlockIdentifier | None = None,
        toBlock: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[EventData]:
        return cast(
            Iterable[EventData],
            super().get_logs(
                argument_filters=argument_filters, fromBlock=fromBlock, toBlock=toBlock, block_hash=block_hash
            ),
        )

    def create_filter(  # type: ignore
        self: "IMorphoBlueHyperdriveApprovalContractEvent",
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        fromBlock: BlockIdentifier | None = None,
        toBlock: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters, fromBlock=fromBlock, toBlock=toBlock, address=address, topics=topics
            ),
        )

    @classmethod
    def create_filter(  # type: ignore
        cls: Type["IMorphoBlueHyperdriveApprovalContractEvent"],
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        fromBlock: BlockIdentifier | None = None,
        toBlock: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters, fromBlock=fromBlock, toBlock=toBlock, address=address, topics=topics
            ),
        )


class IMorphoBlueHyperdriveApprovalForAllContractEvent(ContractEvent):
    """ContractEvent for ApprovalForAll."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # @combomethod destroys return types, so we are redefining functions as both class and instance
    # pylint: disable=function-redefined

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    def get_logs(  # type: ignore
        self: "IMorphoBlueHyperdriveApprovalForAllContractEvent",
        argument_filters: dict[str, Any] | None = None,
        fromBlock: BlockIdentifier | None = None,
        toBlock: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[EventData]:
        return cast(
            Iterable[EventData],
            super().get_logs(
                argument_filters=argument_filters, fromBlock=fromBlock, toBlock=toBlock, block_hash=block_hash
            ),
        )

    @classmethod
    def get_logs(  # type: ignore
        cls: Type["IMorphoBlueHyperdriveApprovalForAllContractEvent"],
        argument_filters: dict[str, Any] | None = None,
        fromBlock: BlockIdentifier | None = None,
        toBlock: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[EventData]:
        return cast(
            Iterable[EventData],
            super().get_logs(
                argument_filters=argument_filters, fromBlock=fromBlock, toBlock=toBlock, block_hash=block_hash
            ),
        )

    def create_filter(  # type: ignore
        self: "IMorphoBlueHyperdriveApprovalForAllContractEvent",
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        fromBlock: BlockIdentifier | None = None,
        toBlock: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters, fromBlock=fromBlock, toBlock=toBlock, address=address, topics=topics
            ),
        )

    @classmethod
    def create_filter(  # type: ignore
        cls: Type["IMorphoBlueHyperdriveApprovalForAllContractEvent"],
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        fromBlock: BlockIdentifier | None = None,
        toBlock: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters, fromBlock=fromBlock, toBlock=toBlock, address=address, topics=topics
            ),
        )


class IMorphoBlueHyperdriveCheckpointRewarderUpdatedContractEvent(ContractEvent):
    """ContractEvent for CheckpointRewarderUpdated."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # @combomethod destroys return types, so we are redefining functions as both class and instance
    # pylint: disable=function-redefined

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    def get_logs(  # type: ignore
        self: "IMorphoBlueHyperdriveCheckpointRewarderUpdatedContractEvent",
        argument_filters: dict[str, Any] | None = None,
        fromBlock: BlockIdentifier | None = None,
        toBlock: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[EventData]:
        return cast(
            Iterable[EventData],
            super().get_logs(
                argument_filters=argument_filters, fromBlock=fromBlock, toBlock=toBlock, block_hash=block_hash
            ),
        )

    @classmethod
    def get_logs(  # type: ignore
        cls: Type["IMorphoBlueHyperdriveCheckpointRewarderUpdatedContractEvent"],
        argument_filters: dict[str, Any] | None = None,
        fromBlock: BlockIdentifier | None = None,
        toBlock: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[EventData]:
        return cast(
            Iterable[EventData],
            super().get_logs(
                argument_filters=argument_filters, fromBlock=fromBlock, toBlock=toBlock, block_hash=block_hash
            ),
        )

    def create_filter(  # type: ignore
        self: "IMorphoBlueHyperdriveCheckpointRewarderUpdatedContractEvent",
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        fromBlock: BlockIdentifier | None = None,
        toBlock: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters, fromBlock=fromBlock, toBlock=toBlock, address=address, topics=topics
            ),
        )

    @classmethod
    def create_filter(  # type: ignore
        cls: Type["IMorphoBlueHyperdriveCheckpointRewarderUpdatedContractEvent"],
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        fromBlock: BlockIdentifier | None = None,
        toBlock: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters, fromBlock=fromBlock, toBlock=toBlock, address=address, topics=topics
            ),
        )


class IMorphoBlueHyperdriveCloseLongContractEvent(ContractEvent):
    """ContractEvent for CloseLong."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # @combomethod destroys return types, so we are redefining functions as both class and instance
    # pylint: disable=function-redefined

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    def get_logs(  # type: ignore
        self: "IMorphoBlueHyperdriveCloseLongContractEvent",
        argument_filters: dict[str, Any] | None = None,
        fromBlock: BlockIdentifier | None = None,
        toBlock: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[EventData]:
        return cast(
            Iterable[EventData],
            super().get_logs(
                argument_filters=argument_filters, fromBlock=fromBlock, toBlock=toBlock, block_hash=block_hash
            ),
        )

    @classmethod
    def get_logs(  # type: ignore
        cls: Type["IMorphoBlueHyperdriveCloseLongContractEvent"],
        argument_filters: dict[str, Any] | None = None,
        fromBlock: BlockIdentifier | None = None,
        toBlock: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[EventData]:
        return cast(
            Iterable[EventData],
            super().get_logs(
                argument_filters=argument_filters, fromBlock=fromBlock, toBlock=toBlock, block_hash=block_hash
            ),
        )

    def create_filter(  # type: ignore
        self: "IMorphoBlueHyperdriveCloseLongContractEvent",
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        fromBlock: BlockIdentifier | None = None,
        toBlock: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters, fromBlock=fromBlock, toBlock=toBlock, address=address, topics=topics
            ),
        )

    @classmethod
    def create_filter(  # type: ignore
        cls: Type["IMorphoBlueHyperdriveCloseLongContractEvent"],
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        fromBlock: BlockIdentifier | None = None,
        toBlock: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters, fromBlock=fromBlock, toBlock=toBlock, address=address, topics=topics
            ),
        )


class IMorphoBlueHyperdriveCloseShortContractEvent(ContractEvent):
    """ContractEvent for CloseShort."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # @combomethod destroys return types, so we are redefining functions as both class and instance
    # pylint: disable=function-redefined

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    def get_logs(  # type: ignore
        self: "IMorphoBlueHyperdriveCloseShortContractEvent",
        argument_filters: dict[str, Any] | None = None,
        fromBlock: BlockIdentifier | None = None,
        toBlock: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[EventData]:
        return cast(
            Iterable[EventData],
            super().get_logs(
                argument_filters=argument_filters, fromBlock=fromBlock, toBlock=toBlock, block_hash=block_hash
            ),
        )

    @classmethod
    def get_logs(  # type: ignore
        cls: Type["IMorphoBlueHyperdriveCloseShortContractEvent"],
        argument_filters: dict[str, Any] | None = None,
        fromBlock: BlockIdentifier | None = None,
        toBlock: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[EventData]:
        return cast(
            Iterable[EventData],
            super().get_logs(
                argument_filters=argument_filters, fromBlock=fromBlock, toBlock=toBlock, block_hash=block_hash
            ),
        )

    def create_filter(  # type: ignore
        self: "IMorphoBlueHyperdriveCloseShortContractEvent",
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        fromBlock: BlockIdentifier | None = None,
        toBlock: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters, fromBlock=fromBlock, toBlock=toBlock, address=address, topics=topics
            ),
        )

    @classmethod
    def create_filter(  # type: ignore
        cls: Type["IMorphoBlueHyperdriveCloseShortContractEvent"],
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        fromBlock: BlockIdentifier | None = None,
        toBlock: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters, fromBlock=fromBlock, toBlock=toBlock, address=address, topics=topics
            ),
        )


class IMorphoBlueHyperdriveCollectGovernanceFeeContractEvent(ContractEvent):
    """ContractEvent for CollectGovernanceFee."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # @combomethod destroys return types, so we are redefining functions as both class and instance
    # pylint: disable=function-redefined

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    def get_logs(  # type: ignore
        self: "IMorphoBlueHyperdriveCollectGovernanceFeeContractEvent",
        argument_filters: dict[str, Any] | None = None,
        fromBlock: BlockIdentifier | None = None,
        toBlock: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[EventData]:
        return cast(
            Iterable[EventData],
            super().get_logs(
                argument_filters=argument_filters, fromBlock=fromBlock, toBlock=toBlock, block_hash=block_hash
            ),
        )

    @classmethod
    def get_logs(  # type: ignore
        cls: Type["IMorphoBlueHyperdriveCollectGovernanceFeeContractEvent"],
        argument_filters: dict[str, Any] | None = None,
        fromBlock: BlockIdentifier | None = None,
        toBlock: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[EventData]:
        return cast(
            Iterable[EventData],
            super().get_logs(
                argument_filters=argument_filters, fromBlock=fromBlock, toBlock=toBlock, block_hash=block_hash
            ),
        )

    def create_filter(  # type: ignore
        self: "IMorphoBlueHyperdriveCollectGovernanceFeeContractEvent",
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        fromBlock: BlockIdentifier | None = None,
        toBlock: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters, fromBlock=fromBlock, toBlock=toBlock, address=address, topics=topics
            ),
        )

    @classmethod
    def create_filter(  # type: ignore
        cls: Type["IMorphoBlueHyperdriveCollectGovernanceFeeContractEvent"],
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        fromBlock: BlockIdentifier | None = None,
        toBlock: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters, fromBlock=fromBlock, toBlock=toBlock, address=address, topics=topics
            ),
        )


class IMorphoBlueHyperdriveCreateCheckpointContractEvent(ContractEvent):
    """ContractEvent for CreateCheckpoint."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # @combomethod destroys return types, so we are redefining functions as both class and instance
    # pylint: disable=function-redefined

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    def get_logs(  # type: ignore
        self: "IMorphoBlueHyperdriveCreateCheckpointContractEvent",
        argument_filters: dict[str, Any] | None = None,
        fromBlock: BlockIdentifier | None = None,
        toBlock: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[EventData]:
        return cast(
            Iterable[EventData],
            super().get_logs(
                argument_filters=argument_filters, fromBlock=fromBlock, toBlock=toBlock, block_hash=block_hash
            ),
        )

    @classmethod
    def get_logs(  # type: ignore
        cls: Type["IMorphoBlueHyperdriveCreateCheckpointContractEvent"],
        argument_filters: dict[str, Any] | None = None,
        fromBlock: BlockIdentifier | None = None,
        toBlock: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[EventData]:
        return cast(
            Iterable[EventData],
            super().get_logs(
                argument_filters=argument_filters, fromBlock=fromBlock, toBlock=toBlock, block_hash=block_hash
            ),
        )

    def create_filter(  # type: ignore
        self: "IMorphoBlueHyperdriveCreateCheckpointContractEvent",
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        fromBlock: BlockIdentifier | None = None,
        toBlock: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters, fromBlock=fromBlock, toBlock=toBlock, address=address, topics=topics
            ),
        )

    @classmethod
    def create_filter(  # type: ignore
        cls: Type["IMorphoBlueHyperdriveCreateCheckpointContractEvent"],
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        fromBlock: BlockIdentifier | None = None,
        toBlock: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters, fromBlock=fromBlock, toBlock=toBlock, address=address, topics=topics
            ),
        )


class IMorphoBlueHyperdriveFeeCollectorUpdatedContractEvent(ContractEvent):
    """ContractEvent for FeeCollectorUpdated."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # @combomethod destroys return types, so we are redefining functions as both class and instance
    # pylint: disable=function-redefined

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    def get_logs(  # type: ignore
        self: "IMorphoBlueHyperdriveFeeCollectorUpdatedContractEvent",
        argument_filters: dict[str, Any] | None = None,
        fromBlock: BlockIdentifier | None = None,
        toBlock: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[EventData]:
        return cast(
            Iterable[EventData],
            super().get_logs(
                argument_filters=argument_filters, fromBlock=fromBlock, toBlock=toBlock, block_hash=block_hash
            ),
        )

    @classmethod
    def get_logs(  # type: ignore
        cls: Type["IMorphoBlueHyperdriveFeeCollectorUpdatedContractEvent"],
        argument_filters: dict[str, Any] | None = None,
        fromBlock: BlockIdentifier | None = None,
        toBlock: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[EventData]:
        return cast(
            Iterable[EventData],
            super().get_logs(
                argument_filters=argument_filters, fromBlock=fromBlock, toBlock=toBlock, block_hash=block_hash
            ),
        )

    def create_filter(  # type: ignore
        self: "IMorphoBlueHyperdriveFeeCollectorUpdatedContractEvent",
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        fromBlock: BlockIdentifier | None = None,
        toBlock: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters, fromBlock=fromBlock, toBlock=toBlock, address=address, topics=topics
            ),
        )

    @classmethod
    def create_filter(  # type: ignore
        cls: Type["IMorphoBlueHyperdriveFeeCollectorUpdatedContractEvent"],
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        fromBlock: BlockIdentifier | None = None,
        toBlock: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters, fromBlock=fromBlock, toBlock=toBlock, address=address, topics=topics
            ),
        )


class IMorphoBlueHyperdriveGovernanceUpdatedContractEvent(ContractEvent):
    """ContractEvent for GovernanceUpdated."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # @combomethod destroys return types, so we are redefining functions as both class and instance
    # pylint: disable=function-redefined

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    def get_logs(  # type: ignore
        self: "IMorphoBlueHyperdriveGovernanceUpdatedContractEvent",
        argument_filters: dict[str, Any] | None = None,
        fromBlock: BlockIdentifier | None = None,
        toBlock: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[EventData]:
        return cast(
            Iterable[EventData],
            super().get_logs(
                argument_filters=argument_filters, fromBlock=fromBlock, toBlock=toBlock, block_hash=block_hash
            ),
        )

    @classmethod
    def get_logs(  # type: ignore
        cls: Type["IMorphoBlueHyperdriveGovernanceUpdatedContractEvent"],
        argument_filters: dict[str, Any] | None = None,
        fromBlock: BlockIdentifier | None = None,
        toBlock: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[EventData]:
        return cast(
            Iterable[EventData],
            super().get_logs(
                argument_filters=argument_filters, fromBlock=fromBlock, toBlock=toBlock, block_hash=block_hash
            ),
        )

    def create_filter(  # type: ignore
        self: "IMorphoBlueHyperdriveGovernanceUpdatedContractEvent",
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        fromBlock: BlockIdentifier | None = None,
        toBlock: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters, fromBlock=fromBlock, toBlock=toBlock, address=address, topics=topics
            ),
        )

    @classmethod
    def create_filter(  # type: ignore
        cls: Type["IMorphoBlueHyperdriveGovernanceUpdatedContractEvent"],
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        fromBlock: BlockIdentifier | None = None,
        toBlock: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters, fromBlock=fromBlock, toBlock=toBlock, address=address, topics=topics
            ),
        )


class IMorphoBlueHyperdriveInitializeContractEvent(ContractEvent):
    """ContractEvent for Initialize."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # @combomethod destroys return types, so we are redefining functions as both class and instance
    # pylint: disable=function-redefined

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    def get_logs(  # type: ignore
        self: "IMorphoBlueHyperdriveInitializeContractEvent",
        argument_filters: dict[str, Any] | None = None,
        fromBlock: BlockIdentifier | None = None,
        toBlock: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[EventData]:
        return cast(
            Iterable[EventData],
            super().get_logs(
                argument_filters=argument_filters, fromBlock=fromBlock, toBlock=toBlock, block_hash=block_hash
            ),
        )

    @classmethod
    def get_logs(  # type: ignore
        cls: Type["IMorphoBlueHyperdriveInitializeContractEvent"],
        argument_filters: dict[str, Any] | None = None,
        fromBlock: BlockIdentifier | None = None,
        toBlock: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[EventData]:
        return cast(
            Iterable[EventData],
            super().get_logs(
                argument_filters=argument_filters, fromBlock=fromBlock, toBlock=toBlock, block_hash=block_hash
            ),
        )

    def create_filter(  # type: ignore
        self: "IMorphoBlueHyperdriveInitializeContractEvent",
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        fromBlock: BlockIdentifier | None = None,
        toBlock: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters, fromBlock=fromBlock, toBlock=toBlock, address=address, topics=topics
            ),
        )

    @classmethod
    def create_filter(  # type: ignore
        cls: Type["IMorphoBlueHyperdriveInitializeContractEvent"],
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        fromBlock: BlockIdentifier | None = None,
        toBlock: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters, fromBlock=fromBlock, toBlock=toBlock, address=address, topics=topics
            ),
        )


class IMorphoBlueHyperdriveOpenLongContractEvent(ContractEvent):
    """ContractEvent for OpenLong."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # @combomethod destroys return types, so we are redefining functions as both class and instance
    # pylint: disable=function-redefined

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    def get_logs(  # type: ignore
        self: "IMorphoBlueHyperdriveOpenLongContractEvent",
        argument_filters: dict[str, Any] | None = None,
        fromBlock: BlockIdentifier | None = None,
        toBlock: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[EventData]:
        return cast(
            Iterable[EventData],
            super().get_logs(
                argument_filters=argument_filters, fromBlock=fromBlock, toBlock=toBlock, block_hash=block_hash
            ),
        )

    @classmethod
    def get_logs(  # type: ignore
        cls: Type["IMorphoBlueHyperdriveOpenLongContractEvent"],
        argument_filters: dict[str, Any] | None = None,
        fromBlock: BlockIdentifier | None = None,
        toBlock: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[EventData]:
        return cast(
            Iterable[EventData],
            super().get_logs(
                argument_filters=argument_filters, fromBlock=fromBlock, toBlock=toBlock, block_hash=block_hash
            ),
        )

    def create_filter(  # type: ignore
        self: "IMorphoBlueHyperdriveOpenLongContractEvent",
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        fromBlock: BlockIdentifier | None = None,
        toBlock: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters, fromBlock=fromBlock, toBlock=toBlock, address=address, topics=topics
            ),
        )

    @classmethod
    def create_filter(  # type: ignore
        cls: Type["IMorphoBlueHyperdriveOpenLongContractEvent"],
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        fromBlock: BlockIdentifier | None = None,
        toBlock: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters, fromBlock=fromBlock, toBlock=toBlock, address=address, topics=topics
            ),
        )


class IMorphoBlueHyperdriveOpenShortContractEvent(ContractEvent):
    """ContractEvent for OpenShort."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # @combomethod destroys return types, so we are redefining functions as both class and instance
    # pylint: disable=function-redefined

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    def get_logs(  # type: ignore
        self: "IMorphoBlueHyperdriveOpenShortContractEvent",
        argument_filters: dict[str, Any] | None = None,
        fromBlock: BlockIdentifier | None = None,
        toBlock: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[EventData]:
        return cast(
            Iterable[EventData],
            super().get_logs(
                argument_filters=argument_filters, fromBlock=fromBlock, toBlock=toBlock, block_hash=block_hash
            ),
        )

    @classmethod
    def get_logs(  # type: ignore
        cls: Type["IMorphoBlueHyperdriveOpenShortContractEvent"],
        argument_filters: dict[str, Any] | None = None,
        fromBlock: BlockIdentifier | None = None,
        toBlock: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[EventData]:
        return cast(
            Iterable[EventData],
            super().get_logs(
                argument_filters=argument_filters, fromBlock=fromBlock, toBlock=toBlock, block_hash=block_hash
            ),
        )

    def create_filter(  # type: ignore
        self: "IMorphoBlueHyperdriveOpenShortContractEvent",
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        fromBlock: BlockIdentifier | None = None,
        toBlock: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters, fromBlock=fromBlock, toBlock=toBlock, address=address, topics=topics
            ),
        )

    @classmethod
    def create_filter(  # type: ignore
        cls: Type["IMorphoBlueHyperdriveOpenShortContractEvent"],
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        fromBlock: BlockIdentifier | None = None,
        toBlock: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters, fromBlock=fromBlock, toBlock=toBlock, address=address, topics=topics
            ),
        )


class IMorphoBlueHyperdrivePauseStatusUpdatedContractEvent(ContractEvent):
    """ContractEvent for PauseStatusUpdated."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # @combomethod destroys return types, so we are redefining functions as both class and instance
    # pylint: disable=function-redefined

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    def get_logs(  # type: ignore
        self: "IMorphoBlueHyperdrivePauseStatusUpdatedContractEvent",
        argument_filters: dict[str, Any] | None = None,
        fromBlock: BlockIdentifier | None = None,
        toBlock: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[EventData]:
        return cast(
            Iterable[EventData],
            super().get_logs(
                argument_filters=argument_filters, fromBlock=fromBlock, toBlock=toBlock, block_hash=block_hash
            ),
        )

    @classmethod
    def get_logs(  # type: ignore
        cls: Type["IMorphoBlueHyperdrivePauseStatusUpdatedContractEvent"],
        argument_filters: dict[str, Any] | None = None,
        fromBlock: BlockIdentifier | None = None,
        toBlock: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[EventData]:
        return cast(
            Iterable[EventData],
            super().get_logs(
                argument_filters=argument_filters, fromBlock=fromBlock, toBlock=toBlock, block_hash=block_hash
            ),
        )

    def create_filter(  # type: ignore
        self: "IMorphoBlueHyperdrivePauseStatusUpdatedContractEvent",
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        fromBlock: BlockIdentifier | None = None,
        toBlock: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters, fromBlock=fromBlock, toBlock=toBlock, address=address, topics=topics
            ),
        )

    @classmethod
    def create_filter(  # type: ignore
        cls: Type["IMorphoBlueHyperdrivePauseStatusUpdatedContractEvent"],
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        fromBlock: BlockIdentifier | None = None,
        toBlock: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters, fromBlock=fromBlock, toBlock=toBlock, address=address, topics=topics
            ),
        )


class IMorphoBlueHyperdrivePauserUpdatedContractEvent(ContractEvent):
    """ContractEvent for PauserUpdated."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # @combomethod destroys return types, so we are redefining functions as both class and instance
    # pylint: disable=function-redefined

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    def get_logs(  # type: ignore
        self: "IMorphoBlueHyperdrivePauserUpdatedContractEvent",
        argument_filters: dict[str, Any] | None = None,
        fromBlock: BlockIdentifier | None = None,
        toBlock: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[EventData]:
        return cast(
            Iterable[EventData],
            super().get_logs(
                argument_filters=argument_filters, fromBlock=fromBlock, toBlock=toBlock, block_hash=block_hash
            ),
        )

    @classmethod
    def get_logs(  # type: ignore
        cls: Type["IMorphoBlueHyperdrivePauserUpdatedContractEvent"],
        argument_filters: dict[str, Any] | None = None,
        fromBlock: BlockIdentifier | None = None,
        toBlock: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[EventData]:
        return cast(
            Iterable[EventData],
            super().get_logs(
                argument_filters=argument_filters, fromBlock=fromBlock, toBlock=toBlock, block_hash=block_hash
            ),
        )

    def create_filter(  # type: ignore
        self: "IMorphoBlueHyperdrivePauserUpdatedContractEvent",
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        fromBlock: BlockIdentifier | None = None,
        toBlock: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters, fromBlock=fromBlock, toBlock=toBlock, address=address, topics=topics
            ),
        )

    @classmethod
    def create_filter(  # type: ignore
        cls: Type["IMorphoBlueHyperdrivePauserUpdatedContractEvent"],
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        fromBlock: BlockIdentifier | None = None,
        toBlock: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters, fromBlock=fromBlock, toBlock=toBlock, address=address, topics=topics
            ),
        )


class IMorphoBlueHyperdriveRedeemWithdrawalSharesContractEvent(ContractEvent):
    """ContractEvent for RedeemWithdrawalShares."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # @combomethod destroys return types, so we are redefining functions as both class and instance
    # pylint: disable=function-redefined

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    def get_logs(  # type: ignore
        self: "IMorphoBlueHyperdriveRedeemWithdrawalSharesContractEvent",
        argument_filters: dict[str, Any] | None = None,
        fromBlock: BlockIdentifier | None = None,
        toBlock: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[EventData]:
        return cast(
            Iterable[EventData],
            super().get_logs(
                argument_filters=argument_filters, fromBlock=fromBlock, toBlock=toBlock, block_hash=block_hash
            ),
        )

    @classmethod
    def get_logs(  # type: ignore
        cls: Type["IMorphoBlueHyperdriveRedeemWithdrawalSharesContractEvent"],
        argument_filters: dict[str, Any] | None = None,
        fromBlock: BlockIdentifier | None = None,
        toBlock: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[EventData]:
        return cast(
            Iterable[EventData],
            super().get_logs(
                argument_filters=argument_filters, fromBlock=fromBlock, toBlock=toBlock, block_hash=block_hash
            ),
        )

    def create_filter(  # type: ignore
        self: "IMorphoBlueHyperdriveRedeemWithdrawalSharesContractEvent",
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        fromBlock: BlockIdentifier | None = None,
        toBlock: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters, fromBlock=fromBlock, toBlock=toBlock, address=address, topics=topics
            ),
        )

    @classmethod
    def create_filter(  # type: ignore
        cls: Type["IMorphoBlueHyperdriveRedeemWithdrawalSharesContractEvent"],
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        fromBlock: BlockIdentifier | None = None,
        toBlock: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters, fromBlock=fromBlock, toBlock=toBlock, address=address, topics=topics
            ),
        )


class IMorphoBlueHyperdriveRemoveLiquidityContractEvent(ContractEvent):
    """ContractEvent for RemoveLiquidity."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # @combomethod destroys return types, so we are redefining functions as both class and instance
    # pylint: disable=function-redefined

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    def get_logs(  # type: ignore
        self: "IMorphoBlueHyperdriveRemoveLiquidityContractEvent",
        argument_filters: dict[str, Any] | None = None,
        fromBlock: BlockIdentifier | None = None,
        toBlock: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[EventData]:
        return cast(
            Iterable[EventData],
            super().get_logs(
                argument_filters=argument_filters, fromBlock=fromBlock, toBlock=toBlock, block_hash=block_hash
            ),
        )

    @classmethod
    def get_logs(  # type: ignore
        cls: Type["IMorphoBlueHyperdriveRemoveLiquidityContractEvent"],
        argument_filters: dict[str, Any] | None = None,
        fromBlock: BlockIdentifier | None = None,
        toBlock: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[EventData]:
        return cast(
            Iterable[EventData],
            super().get_logs(
                argument_filters=argument_filters, fromBlock=fromBlock, toBlock=toBlock, block_hash=block_hash
            ),
        )

    def create_filter(  # type: ignore
        self: "IMorphoBlueHyperdriveRemoveLiquidityContractEvent",
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        fromBlock: BlockIdentifier | None = None,
        toBlock: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters, fromBlock=fromBlock, toBlock=toBlock, address=address, topics=topics
            ),
        )

    @classmethod
    def create_filter(  # type: ignore
        cls: Type["IMorphoBlueHyperdriveRemoveLiquidityContractEvent"],
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        fromBlock: BlockIdentifier | None = None,
        toBlock: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters, fromBlock=fromBlock, toBlock=toBlock, address=address, topics=topics
            ),
        )


class IMorphoBlueHyperdriveSweepContractEvent(ContractEvent):
    """ContractEvent for Sweep."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # @combomethod destroys return types, so we are redefining functions as both class and instance
    # pylint: disable=function-redefined

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    def get_logs(  # type: ignore
        self: "IMorphoBlueHyperdriveSweepContractEvent",
        argument_filters: dict[str, Any] | None = None,
        fromBlock: BlockIdentifier | None = None,
        toBlock: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[EventData]:
        return cast(
            Iterable[EventData],
            super().get_logs(
                argument_filters=argument_filters, fromBlock=fromBlock, toBlock=toBlock, block_hash=block_hash
            ),
        )

    @classmethod
    def get_logs(  # type: ignore
        cls: Type["IMorphoBlueHyperdriveSweepContractEvent"],
        argument_filters: dict[str, Any] | None = None,
        fromBlock: BlockIdentifier | None = None,
        toBlock: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[EventData]:
        return cast(
            Iterable[EventData],
            super().get_logs(
                argument_filters=argument_filters, fromBlock=fromBlock, toBlock=toBlock, block_hash=block_hash
            ),
        )

    def create_filter(  # type: ignore
        self: "IMorphoBlueHyperdriveSweepContractEvent",
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        fromBlock: BlockIdentifier | None = None,
        toBlock: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters, fromBlock=fromBlock, toBlock=toBlock, address=address, topics=topics
            ),
        )

    @classmethod
    def create_filter(  # type: ignore
        cls: Type["IMorphoBlueHyperdriveSweepContractEvent"],
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        fromBlock: BlockIdentifier | None = None,
        toBlock: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters, fromBlock=fromBlock, toBlock=toBlock, address=address, topics=topics
            ),
        )


class IMorphoBlueHyperdriveSweepCollectorUpdatedContractEvent(ContractEvent):
    """ContractEvent for SweepCollectorUpdated."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # @combomethod destroys return types, so we are redefining functions as both class and instance
    # pylint: disable=function-redefined

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    def get_logs(  # type: ignore
        self: "IMorphoBlueHyperdriveSweepCollectorUpdatedContractEvent",
        argument_filters: dict[str, Any] | None = None,
        fromBlock: BlockIdentifier | None = None,
        toBlock: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[EventData]:
        return cast(
            Iterable[EventData],
            super().get_logs(
                argument_filters=argument_filters, fromBlock=fromBlock, toBlock=toBlock, block_hash=block_hash
            ),
        )

    @classmethod
    def get_logs(  # type: ignore
        cls: Type["IMorphoBlueHyperdriveSweepCollectorUpdatedContractEvent"],
        argument_filters: dict[str, Any] | None = None,
        fromBlock: BlockIdentifier | None = None,
        toBlock: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[EventData]:
        return cast(
            Iterable[EventData],
            super().get_logs(
                argument_filters=argument_filters, fromBlock=fromBlock, toBlock=toBlock, block_hash=block_hash
            ),
        )

    def create_filter(  # type: ignore
        self: "IMorphoBlueHyperdriveSweepCollectorUpdatedContractEvent",
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        fromBlock: BlockIdentifier | None = None,
        toBlock: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters, fromBlock=fromBlock, toBlock=toBlock, address=address, topics=topics
            ),
        )

    @classmethod
    def create_filter(  # type: ignore
        cls: Type["IMorphoBlueHyperdriveSweepCollectorUpdatedContractEvent"],
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        fromBlock: BlockIdentifier | None = None,
        toBlock: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters, fromBlock=fromBlock, toBlock=toBlock, address=address, topics=topics
            ),
        )


class IMorphoBlueHyperdriveTransferSingleContractEvent(ContractEvent):
    """ContractEvent for TransferSingle."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # @combomethod destroys return types, so we are redefining functions as both class and instance
    # pylint: disable=function-redefined

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    def get_logs(  # type: ignore
        self: "IMorphoBlueHyperdriveTransferSingleContractEvent",
        argument_filters: dict[str, Any] | None = None,
        fromBlock: BlockIdentifier | None = None,
        toBlock: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[EventData]:
        return cast(
            Iterable[EventData],
            super().get_logs(
                argument_filters=argument_filters, fromBlock=fromBlock, toBlock=toBlock, block_hash=block_hash
            ),
        )

    @classmethod
    def get_logs(  # type: ignore
        cls: Type["IMorphoBlueHyperdriveTransferSingleContractEvent"],
        argument_filters: dict[str, Any] | None = None,
        fromBlock: BlockIdentifier | None = None,
        toBlock: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[EventData]:
        return cast(
            Iterable[EventData],
            super().get_logs(
                argument_filters=argument_filters, fromBlock=fromBlock, toBlock=toBlock, block_hash=block_hash
            ),
        )

    def create_filter(  # type: ignore
        self: "IMorphoBlueHyperdriveTransferSingleContractEvent",
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        fromBlock: BlockIdentifier | None = None,
        toBlock: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters, fromBlock=fromBlock, toBlock=toBlock, address=address, topics=topics
            ),
        )

    @classmethod
    def create_filter(  # type: ignore
        cls: Type["IMorphoBlueHyperdriveTransferSingleContractEvent"],
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        fromBlock: BlockIdentifier | None = None,
        toBlock: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters, fromBlock=fromBlock, toBlock=toBlock, address=address, topics=topics
            ),
        )


class IMorphoBlueHyperdriveContractEvents(ContractEvents):
    """ContractEvents for the IMorphoBlueHyperdrive contract."""

    AddLiquidity: IMorphoBlueHyperdriveAddLiquidityContractEvent

    Approval: IMorphoBlueHyperdriveApprovalContractEvent

    ApprovalForAll: IMorphoBlueHyperdriveApprovalForAllContractEvent

    CheckpointRewarderUpdated: IMorphoBlueHyperdriveCheckpointRewarderUpdatedContractEvent

    CloseLong: IMorphoBlueHyperdriveCloseLongContractEvent

    CloseShort: IMorphoBlueHyperdriveCloseShortContractEvent

    CollectGovernanceFee: IMorphoBlueHyperdriveCollectGovernanceFeeContractEvent

    CreateCheckpoint: IMorphoBlueHyperdriveCreateCheckpointContractEvent

    FeeCollectorUpdated: IMorphoBlueHyperdriveFeeCollectorUpdatedContractEvent

    GovernanceUpdated: IMorphoBlueHyperdriveGovernanceUpdatedContractEvent

    Initialize: IMorphoBlueHyperdriveInitializeContractEvent

    OpenLong: IMorphoBlueHyperdriveOpenLongContractEvent

    OpenShort: IMorphoBlueHyperdriveOpenShortContractEvent

    PauseStatusUpdated: IMorphoBlueHyperdrivePauseStatusUpdatedContractEvent

    PauserUpdated: IMorphoBlueHyperdrivePauserUpdatedContractEvent

    RedeemWithdrawalShares: IMorphoBlueHyperdriveRedeemWithdrawalSharesContractEvent

    RemoveLiquidity: IMorphoBlueHyperdriveRemoveLiquidityContractEvent

    Sweep: IMorphoBlueHyperdriveSweepContractEvent

    SweepCollectorUpdated: IMorphoBlueHyperdriveSweepCollectorUpdatedContractEvent

    TransferSingle: IMorphoBlueHyperdriveTransferSingleContractEvent

    def __init__(
        self,
        abi: ABI,
        w3: "Web3",
        address: ChecksumAddress | None = None,
    ) -> None:
        super().__init__(abi, w3, address)
        self.AddLiquidity = cast(
            IMorphoBlueHyperdriveAddLiquidityContractEvent,
            IMorphoBlueHyperdriveAddLiquidityContractEvent.factory(
                "AddLiquidity", w3=w3, contract_abi=abi, address=address, event_name="AddLiquidity"
            ),
        )
        self.Approval = cast(
            IMorphoBlueHyperdriveApprovalContractEvent,
            IMorphoBlueHyperdriveApprovalContractEvent.factory(
                "Approval", w3=w3, contract_abi=abi, address=address, event_name="Approval"
            ),
        )
        self.ApprovalForAll = cast(
            IMorphoBlueHyperdriveApprovalForAllContractEvent,
            IMorphoBlueHyperdriveApprovalForAllContractEvent.factory(
                "ApprovalForAll", w3=w3, contract_abi=abi, address=address, event_name="ApprovalForAll"
            ),
        )
        self.CheckpointRewarderUpdated = cast(
            IMorphoBlueHyperdriveCheckpointRewarderUpdatedContractEvent,
            IMorphoBlueHyperdriveCheckpointRewarderUpdatedContractEvent.factory(
                "CheckpointRewarderUpdated",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="CheckpointRewarderUpdated",
            ),
        )
        self.CloseLong = cast(
            IMorphoBlueHyperdriveCloseLongContractEvent,
            IMorphoBlueHyperdriveCloseLongContractEvent.factory(
                "CloseLong", w3=w3, contract_abi=abi, address=address, event_name="CloseLong"
            ),
        )
        self.CloseShort = cast(
            IMorphoBlueHyperdriveCloseShortContractEvent,
            IMorphoBlueHyperdriveCloseShortContractEvent.factory(
                "CloseShort", w3=w3, contract_abi=abi, address=address, event_name="CloseShort"
            ),
        )
        self.CollectGovernanceFee = cast(
            IMorphoBlueHyperdriveCollectGovernanceFeeContractEvent,
            IMorphoBlueHyperdriveCollectGovernanceFeeContractEvent.factory(
                "CollectGovernanceFee", w3=w3, contract_abi=abi, address=address, event_name="CollectGovernanceFee"
            ),
        )
        self.CreateCheckpoint = cast(
            IMorphoBlueHyperdriveCreateCheckpointContractEvent,
            IMorphoBlueHyperdriveCreateCheckpointContractEvent.factory(
                "CreateCheckpoint", w3=w3, contract_abi=abi, address=address, event_name="CreateCheckpoint"
            ),
        )
        self.FeeCollectorUpdated = cast(
            IMorphoBlueHyperdriveFeeCollectorUpdatedContractEvent,
            IMorphoBlueHyperdriveFeeCollectorUpdatedContractEvent.factory(
                "FeeCollectorUpdated", w3=w3, contract_abi=abi, address=address, event_name="FeeCollectorUpdated"
            ),
        )
        self.GovernanceUpdated = cast(
            IMorphoBlueHyperdriveGovernanceUpdatedContractEvent,
            IMorphoBlueHyperdriveGovernanceUpdatedContractEvent.factory(
                "GovernanceUpdated", w3=w3, contract_abi=abi, address=address, event_name="GovernanceUpdated"
            ),
        )
        self.Initialize = cast(
            IMorphoBlueHyperdriveInitializeContractEvent,
            IMorphoBlueHyperdriveInitializeContractEvent.factory(
                "Initialize", w3=w3, contract_abi=abi, address=address, event_name="Initialize"
            ),
        )
        self.OpenLong = cast(
            IMorphoBlueHyperdriveOpenLongContractEvent,
            IMorphoBlueHyperdriveOpenLongContractEvent.factory(
                "OpenLong", w3=w3, contract_abi=abi, address=address, event_name="OpenLong"
            ),
        )
        self.OpenShort = cast(
            IMorphoBlueHyperdriveOpenShortContractEvent,
            IMorphoBlueHyperdriveOpenShortContractEvent.factory(
                "OpenShort", w3=w3, contract_abi=abi, address=address, event_name="OpenShort"
            ),
        )
        self.PauseStatusUpdated = cast(
            IMorphoBlueHyperdrivePauseStatusUpdatedContractEvent,
            IMorphoBlueHyperdrivePauseStatusUpdatedContractEvent.factory(
                "PauseStatusUpdated", w3=w3, contract_abi=abi, address=address, event_name="PauseStatusUpdated"
            ),
        )
        self.PauserUpdated = cast(
            IMorphoBlueHyperdrivePauserUpdatedContractEvent,
            IMorphoBlueHyperdrivePauserUpdatedContractEvent.factory(
                "PauserUpdated", w3=w3, contract_abi=abi, address=address, event_name="PauserUpdated"
            ),
        )
        self.RedeemWithdrawalShares = cast(
            IMorphoBlueHyperdriveRedeemWithdrawalSharesContractEvent,
            IMorphoBlueHyperdriveRedeemWithdrawalSharesContractEvent.factory(
                "RedeemWithdrawalShares", w3=w3, contract_abi=abi, address=address, event_name="RedeemWithdrawalShares"
            ),
        )
        self.RemoveLiquidity = cast(
            IMorphoBlueHyperdriveRemoveLiquidityContractEvent,
            IMorphoBlueHyperdriveRemoveLiquidityContractEvent.factory(
                "RemoveLiquidity", w3=w3, contract_abi=abi, address=address, event_name="RemoveLiquidity"
            ),
        )
        self.Sweep = cast(
            IMorphoBlueHyperdriveSweepContractEvent,
            IMorphoBlueHyperdriveSweepContractEvent.factory(
                "Sweep", w3=w3, contract_abi=abi, address=address, event_name="Sweep"
            ),
        )
        self.SweepCollectorUpdated = cast(
            IMorphoBlueHyperdriveSweepCollectorUpdatedContractEvent,
            IMorphoBlueHyperdriveSweepCollectorUpdatedContractEvent.factory(
                "SweepCollectorUpdated", w3=w3, contract_abi=abi, address=address, event_name="SweepCollectorUpdated"
            ),
        )
        self.TransferSingle = cast(
            IMorphoBlueHyperdriveTransferSingleContractEvent,
            IMorphoBlueHyperdriveTransferSingleContractEvent.factory(
                "TransferSingle", w3=w3, contract_abi=abi, address=address, event_name="TransferSingle"
            ),
        )


class IMorphoBlueHyperdriveBatchInputLengthMismatchContractError:
    """ContractError for BatchInputLengthMismatch."""

    # @combomethod destroys return types, so we are redefining functions as both class and instance
    # pylint: disable=function-redefined

    # 4 byte error selector
    selector: str
    # error signature, i.e. CustomError(uint256,bool)
    signature: str

    # pylint: disable=useless-parent-delegation
    def __init__(
        self: "IMorphoBlueHyperdriveBatchInputLengthMismatchContractError",
    ) -> None:
        self.selector = "0xba430d38"
        self.signature = "BatchInputLengthMismatch()"

    def decode_error_data(  # type: ignore
        self: "IMorphoBlueHyperdriveBatchInputLengthMismatchContractError",
        data: HexBytes,
        # TODO: instead of returning a tuple, return a dataclass with the input names and types just like we do for functions
    ) -> tuple[Any, ...]:
        """Decodes error data returns from a smart contract."""
        error_abi = cast(
            ABIFunction,
            [
                item
                for item in imorphobluehyperdrive_abi
                if item.get("name") == "BatchInputLengthMismatch" and item.get("type") == "error"
            ][0],
        )
        types = get_abi_input_types(error_abi)
        abi_codec = ABICodec(default_registry)
        decoded = abi_codec.decode(types, data)
        return decoded

    @classmethod
    def decode_error_data(  # type: ignore
        cls: Type["IMorphoBlueHyperdriveBatchInputLengthMismatchContractError"],
        data: HexBytes,
    ) -> tuple[Any, ...]:
        """Decodes error data returns from a smart contract."""
        error_abi = cast(
            ABIFunction,
            [
                item
                for item in imorphobluehyperdrive_abi
                if item.get("name") == "BatchInputLengthMismatch" and item.get("type") == "error"
            ][0],
        )
        types = get_abi_input_types(error_abi)
        abi_codec = ABICodec(default_registry)
        decoded = abi_codec.decode(types, data)
        return decoded


class IMorphoBlueHyperdriveBelowMinimumContributionContractError:
    """ContractError for BelowMinimumContribution."""

    # @combomethod destroys return types, so we are redefining functions as both class and instance
    # pylint: disable=function-redefined

    # 4 byte error selector
    selector: str
    # error signature, i.e. CustomError(uint256,bool)
    signature: str

    # pylint: disable=useless-parent-delegation
    def __init__(
        self: "IMorphoBlueHyperdriveBelowMinimumContributionContractError",
    ) -> None:
        self.selector = "0xabed41c4"
        self.signature = "BelowMinimumContribution()"

    def decode_error_data(  # type: ignore
        self: "IMorphoBlueHyperdriveBelowMinimumContributionContractError",
        data: HexBytes,
        # TODO: instead of returning a tuple, return a dataclass with the input names and types just like we do for functions
    ) -> tuple[Any, ...]:
        """Decodes error data returns from a smart contract."""
        error_abi = cast(
            ABIFunction,
            [
                item
                for item in imorphobluehyperdrive_abi
                if item.get("name") == "BelowMinimumContribution" and item.get("type") == "error"
            ][0],
        )
        types = get_abi_input_types(error_abi)
        abi_codec = ABICodec(default_registry)
        decoded = abi_codec.decode(types, data)
        return decoded

    @classmethod
    def decode_error_data(  # type: ignore
        cls: Type["IMorphoBlueHyperdriveBelowMinimumContributionContractError"],
        data: HexBytes,
    ) -> tuple[Any, ...]:
        """Decodes error data returns from a smart contract."""
        error_abi = cast(
            ABIFunction,
            [
                item
                for item in imorphobluehyperdrive_abi
                if item.get("name") == "BelowMinimumContribution" and item.get("type") == "error"
            ][0],
        )
        types = get_abi_input_types(error_abi)
        abi_codec = ABICodec(default_registry)
        decoded = abi_codec.decode(types, data)
        return decoded


class IMorphoBlueHyperdriveCircuitBreakerTriggeredContractError:
    """ContractError for CircuitBreakerTriggered."""

    # @combomethod destroys return types, so we are redefining functions as both class and instance
    # pylint: disable=function-redefined

    # 4 byte error selector
    selector: str
    # error signature, i.e. CustomError(uint256,bool)
    signature: str

    # pylint: disable=useless-parent-delegation
    def __init__(
        self: "IMorphoBlueHyperdriveCircuitBreakerTriggeredContractError",
    ) -> None:
        self.selector = "0x2a958098"
        self.signature = "CircuitBreakerTriggered()"

    def decode_error_data(  # type: ignore
        self: "IMorphoBlueHyperdriveCircuitBreakerTriggeredContractError",
        data: HexBytes,
        # TODO: instead of returning a tuple, return a dataclass with the input names and types just like we do for functions
    ) -> tuple[Any, ...]:
        """Decodes error data returns from a smart contract."""
        error_abi = cast(
            ABIFunction,
            [
                item
                for item in imorphobluehyperdrive_abi
                if item.get("name") == "CircuitBreakerTriggered" and item.get("type") == "error"
            ][0],
        )
        types = get_abi_input_types(error_abi)
        abi_codec = ABICodec(default_registry)
        decoded = abi_codec.decode(types, data)
        return decoded

    @classmethod
    def decode_error_data(  # type: ignore
        cls: Type["IMorphoBlueHyperdriveCircuitBreakerTriggeredContractError"],
        data: HexBytes,
    ) -> tuple[Any, ...]:
        """Decodes error data returns from a smart contract."""
        error_abi = cast(
            ABIFunction,
            [
                item
                for item in imorphobluehyperdrive_abi
                if item.get("name") == "CircuitBreakerTriggered" and item.get("type") == "error"
            ][0],
        )
        types = get_abi_input_types(error_abi)
        abi_codec = ABICodec(default_registry)
        decoded = abi_codec.decode(types, data)
        return decoded


class IMorphoBlueHyperdriveDecreasedPresentValueWhenAddingLiquidityContractError:
    """ContractError for DecreasedPresentValueWhenAddingLiquidity."""

    # @combomethod destroys return types, so we are redefining functions as both class and instance
    # pylint: disable=function-redefined

    # 4 byte error selector
    selector: str
    # error signature, i.e. CustomError(uint256,bool)
    signature: str

    # pylint: disable=useless-parent-delegation
    def __init__(
        self: "IMorphoBlueHyperdriveDecreasedPresentValueWhenAddingLiquidityContractError",
    ) -> None:
        self.selector = "0x309b2a42"
        self.signature = "DecreasedPresentValueWhenAddingLiquidity()"

    def decode_error_data(  # type: ignore
        self: "IMorphoBlueHyperdriveDecreasedPresentValueWhenAddingLiquidityContractError",
        data: HexBytes,
        # TODO: instead of returning a tuple, return a dataclass with the input names and types just like we do for functions
    ) -> tuple[Any, ...]:
        """Decodes error data returns from a smart contract."""
        error_abi = cast(
            ABIFunction,
            [
                item
                for item in imorphobluehyperdrive_abi
                if item.get("name") == "DecreasedPresentValueWhenAddingLiquidity" and item.get("type") == "error"
            ][0],
        )
        types = get_abi_input_types(error_abi)
        abi_codec = ABICodec(default_registry)
        decoded = abi_codec.decode(types, data)
        return decoded

    @classmethod
    def decode_error_data(  # type: ignore
        cls: Type["IMorphoBlueHyperdriveDecreasedPresentValueWhenAddingLiquidityContractError"],
        data: HexBytes,
    ) -> tuple[Any, ...]:
        """Decodes error data returns from a smart contract."""
        error_abi = cast(
            ABIFunction,
            [
                item
                for item in imorphobluehyperdrive_abi
                if item.get("name") == "DecreasedPresentValueWhenAddingLiquidity" and item.get("type") == "error"
            ][0],
        )
        types = get_abi_input_types(error_abi)
        abi_codec = ABICodec(default_registry)
        decoded = abi_codec.decode(types, data)
        return decoded


class IMorphoBlueHyperdriveDistributeExcessIdleFailedContractError:
    """ContractError for DistributeExcessIdleFailed."""

    # @combomethod destroys return types, so we are redefining functions as both class and instance
    # pylint: disable=function-redefined

    # 4 byte error selector
    selector: str
    # error signature, i.e. CustomError(uint256,bool)
    signature: str

    # pylint: disable=useless-parent-delegation
    def __init__(
        self: "IMorphoBlueHyperdriveDistributeExcessIdleFailedContractError",
    ) -> None:
        self.selector = "0x8bdf918d"
        self.signature = "DistributeExcessIdleFailed()"

    def decode_error_data(  # type: ignore
        self: "IMorphoBlueHyperdriveDistributeExcessIdleFailedContractError",
        data: HexBytes,
        # TODO: instead of returning a tuple, return a dataclass with the input names and types just like we do for functions
    ) -> tuple[Any, ...]:
        """Decodes error data returns from a smart contract."""
        error_abi = cast(
            ABIFunction,
            [
                item
                for item in imorphobluehyperdrive_abi
                if item.get("name") == "DistributeExcessIdleFailed" and item.get("type") == "error"
            ][0],
        )
        types = get_abi_input_types(error_abi)
        abi_codec = ABICodec(default_registry)
        decoded = abi_codec.decode(types, data)
        return decoded

    @classmethod
    def decode_error_data(  # type: ignore
        cls: Type["IMorphoBlueHyperdriveDistributeExcessIdleFailedContractError"],
        data: HexBytes,
    ) -> tuple[Any, ...]:
        """Decodes error data returns from a smart contract."""
        error_abi = cast(
            ABIFunction,
            [
                item
                for item in imorphobluehyperdrive_abi
                if item.get("name") == "DistributeExcessIdleFailed" and item.get("type") == "error"
            ][0],
        )
        types = get_abi_input_types(error_abi)
        abi_codec = ABICodec(default_registry)
        decoded = abi_codec.decode(types, data)
        return decoded


class IMorphoBlueHyperdriveExpInvalidExponentContractError:
    """ContractError for ExpInvalidExponent."""

    # @combomethod destroys return types, so we are redefining functions as both class and instance
    # pylint: disable=function-redefined

    # 4 byte error selector
    selector: str
    # error signature, i.e. CustomError(uint256,bool)
    signature: str

    # pylint: disable=useless-parent-delegation
    def __init__(
        self: "IMorphoBlueHyperdriveExpInvalidExponentContractError",
    ) -> None:
        self.selector = "0x73a2d6b1"
        self.signature = "ExpInvalidExponent()"

    def decode_error_data(  # type: ignore
        self: "IMorphoBlueHyperdriveExpInvalidExponentContractError",
        data: HexBytes,
        # TODO: instead of returning a tuple, return a dataclass with the input names and types just like we do for functions
    ) -> tuple[Any, ...]:
        """Decodes error data returns from a smart contract."""
        error_abi = cast(
            ABIFunction,
            [
                item
                for item in imorphobluehyperdrive_abi
                if item.get("name") == "ExpInvalidExponent" and item.get("type") == "error"
            ][0],
        )
        types = get_abi_input_types(error_abi)
        abi_codec = ABICodec(default_registry)
        decoded = abi_codec.decode(types, data)
        return decoded

    @classmethod
    def decode_error_data(  # type: ignore
        cls: Type["IMorphoBlueHyperdriveExpInvalidExponentContractError"],
        data: HexBytes,
    ) -> tuple[Any, ...]:
        """Decodes error data returns from a smart contract."""
        error_abi = cast(
            ABIFunction,
            [
                item
                for item in imorphobluehyperdrive_abi
                if item.get("name") == "ExpInvalidExponent" and item.get("type") == "error"
            ][0],
        )
        types = get_abi_input_types(error_abi)
        abi_codec = ABICodec(default_registry)
        decoded = abi_codec.decode(types, data)
        return decoded


class IMorphoBlueHyperdriveExpiredDeadlineContractError:
    """ContractError for ExpiredDeadline."""

    # @combomethod destroys return types, so we are redefining functions as both class and instance
    # pylint: disable=function-redefined

    # 4 byte error selector
    selector: str
    # error signature, i.e. CustomError(uint256,bool)
    signature: str

    # pylint: disable=useless-parent-delegation
    def __init__(
        self: "IMorphoBlueHyperdriveExpiredDeadlineContractError",
    ) -> None:
        self.selector = "0xf87d9271"
        self.signature = "ExpiredDeadline()"

    def decode_error_data(  # type: ignore
        self: "IMorphoBlueHyperdriveExpiredDeadlineContractError",
        data: HexBytes,
        # TODO: instead of returning a tuple, return a dataclass with the input names and types just like we do for functions
    ) -> tuple[Any, ...]:
        """Decodes error data returns from a smart contract."""
        error_abi = cast(
            ABIFunction,
            [
                item
                for item in imorphobluehyperdrive_abi
                if item.get("name") == "ExpiredDeadline" and item.get("type") == "error"
            ][0],
        )
        types = get_abi_input_types(error_abi)
        abi_codec = ABICodec(default_registry)
        decoded = abi_codec.decode(types, data)
        return decoded

    @classmethod
    def decode_error_data(  # type: ignore
        cls: Type["IMorphoBlueHyperdriveExpiredDeadlineContractError"],
        data: HexBytes,
    ) -> tuple[Any, ...]:
        """Decodes error data returns from a smart contract."""
        error_abi = cast(
            ABIFunction,
            [
                item
                for item in imorphobluehyperdrive_abi
                if item.get("name") == "ExpiredDeadline" and item.get("type") == "error"
            ][0],
        )
        types = get_abi_input_types(error_abi)
        abi_codec = ABICodec(default_registry)
        decoded = abi_codec.decode(types, data)
        return decoded


class IMorphoBlueHyperdriveInsufficientBalanceContractError:
    """ContractError for InsufficientBalance."""

    # @combomethod destroys return types, so we are redefining functions as both class and instance
    # pylint: disable=function-redefined

    # 4 byte error selector
    selector: str
    # error signature, i.e. CustomError(uint256,bool)
    signature: str

    # pylint: disable=useless-parent-delegation
    def __init__(
        self: "IMorphoBlueHyperdriveInsufficientBalanceContractError",
    ) -> None:
        self.selector = "0xf4d678b8"
        self.signature = "InsufficientBalance()"

    def decode_error_data(  # type: ignore
        self: "IMorphoBlueHyperdriveInsufficientBalanceContractError",
        data: HexBytes,
        # TODO: instead of returning a tuple, return a dataclass with the input names and types just like we do for functions
    ) -> tuple[Any, ...]:
        """Decodes error data returns from a smart contract."""
        error_abi = cast(
            ABIFunction,
            [
                item
                for item in imorphobluehyperdrive_abi
                if item.get("name") == "InsufficientBalance" and item.get("type") == "error"
            ][0],
        )
        types = get_abi_input_types(error_abi)
        abi_codec = ABICodec(default_registry)
        decoded = abi_codec.decode(types, data)
        return decoded

    @classmethod
    def decode_error_data(  # type: ignore
        cls: Type["IMorphoBlueHyperdriveInsufficientBalanceContractError"],
        data: HexBytes,
    ) -> tuple[Any, ...]:
        """Decodes error data returns from a smart contract."""
        error_abi = cast(
            ABIFunction,
            [
                item
                for item in imorphobluehyperdrive_abi
                if item.get("name") == "InsufficientBalance" and item.get("type") == "error"
            ][0],
        )
        types = get_abi_input_types(error_abi)
        abi_codec = ABICodec(default_registry)
        decoded = abi_codec.decode(types, data)
        return decoded


class IMorphoBlueHyperdriveInsufficientLiquidityContractError:
    """ContractError for InsufficientLiquidity."""

    # @combomethod destroys return types, so we are redefining functions as both class and instance
    # pylint: disable=function-redefined

    # 4 byte error selector
    selector: str
    # error signature, i.e. CustomError(uint256,bool)
    signature: str

    # pylint: disable=useless-parent-delegation
    def __init__(
        self: "IMorphoBlueHyperdriveInsufficientLiquidityContractError",
    ) -> None:
        self.selector = "0xbb55fd27"
        self.signature = "InsufficientLiquidity()"

    def decode_error_data(  # type: ignore
        self: "IMorphoBlueHyperdriveInsufficientLiquidityContractError",
        data: HexBytes,
        # TODO: instead of returning a tuple, return a dataclass with the input names and types just like we do for functions
    ) -> tuple[Any, ...]:
        """Decodes error data returns from a smart contract."""
        error_abi = cast(
            ABIFunction,
            [
                item
                for item in imorphobluehyperdrive_abi
                if item.get("name") == "InsufficientLiquidity" and item.get("type") == "error"
            ][0],
        )
        types = get_abi_input_types(error_abi)
        abi_codec = ABICodec(default_registry)
        decoded = abi_codec.decode(types, data)
        return decoded

    @classmethod
    def decode_error_data(  # type: ignore
        cls: Type["IMorphoBlueHyperdriveInsufficientLiquidityContractError"],
        data: HexBytes,
    ) -> tuple[Any, ...]:
        """Decodes error data returns from a smart contract."""
        error_abi = cast(
            ABIFunction,
            [
                item
                for item in imorphobluehyperdrive_abi
                if item.get("name") == "InsufficientLiquidity" and item.get("type") == "error"
            ][0],
        )
        types = get_abi_input_types(error_abi)
        abi_codec = ABICodec(default_registry)
        decoded = abi_codec.decode(types, data)
        return decoded


class IMorphoBlueHyperdriveInvalidAprContractError:
    """ContractError for InvalidApr."""

    # @combomethod destroys return types, so we are redefining functions as both class and instance
    # pylint: disable=function-redefined

    # 4 byte error selector
    selector: str
    # error signature, i.e. CustomError(uint256,bool)
    signature: str

    # pylint: disable=useless-parent-delegation
    def __init__(
        self: "IMorphoBlueHyperdriveInvalidAprContractError",
    ) -> None:
        self.selector = "0x76c22a22"
        self.signature = "InvalidApr()"

    def decode_error_data(  # type: ignore
        self: "IMorphoBlueHyperdriveInvalidAprContractError",
        data: HexBytes,
        # TODO: instead of returning a tuple, return a dataclass with the input names and types just like we do for functions
    ) -> tuple[Any, ...]:
        """Decodes error data returns from a smart contract."""
        error_abi = cast(
            ABIFunction,
            [
                item
                for item in imorphobluehyperdrive_abi
                if item.get("name") == "InvalidApr" and item.get("type") == "error"
            ][0],
        )
        types = get_abi_input_types(error_abi)
        abi_codec = ABICodec(default_registry)
        decoded = abi_codec.decode(types, data)
        return decoded

    @classmethod
    def decode_error_data(  # type: ignore
        cls: Type["IMorphoBlueHyperdriveInvalidAprContractError"],
        data: HexBytes,
    ) -> tuple[Any, ...]:
        """Decodes error data returns from a smart contract."""
        error_abi = cast(
            ABIFunction,
            [
                item
                for item in imorphobluehyperdrive_abi
                if item.get("name") == "InvalidApr" and item.get("type") == "error"
            ][0],
        )
        types = get_abi_input_types(error_abi)
        abi_codec = ABICodec(default_registry)
        decoded = abi_codec.decode(types, data)
        return decoded


class IMorphoBlueHyperdriveInvalidCheckpointTimeContractError:
    """ContractError for InvalidCheckpointTime."""

    # @combomethod destroys return types, so we are redefining functions as both class and instance
    # pylint: disable=function-redefined

    # 4 byte error selector
    selector: str
    # error signature, i.e. CustomError(uint256,bool)
    signature: str

    # pylint: disable=useless-parent-delegation
    def __init__(
        self: "IMorphoBlueHyperdriveInvalidCheckpointTimeContractError",
    ) -> None:
        self.selector = "0xecd29e81"
        self.signature = "InvalidCheckpointTime()"

    def decode_error_data(  # type: ignore
        self: "IMorphoBlueHyperdriveInvalidCheckpointTimeContractError",
        data: HexBytes,
        # TODO: instead of returning a tuple, return a dataclass with the input names and types just like we do for functions
    ) -> tuple[Any, ...]:
        """Decodes error data returns from a smart contract."""
        error_abi = cast(
            ABIFunction,
            [
                item
                for item in imorphobluehyperdrive_abi
                if item.get("name") == "InvalidCheckpointTime" and item.get("type") == "error"
            ][0],
        )
        types = get_abi_input_types(error_abi)
        abi_codec = ABICodec(default_registry)
        decoded = abi_codec.decode(types, data)
        return decoded

    @classmethod
    def decode_error_data(  # type: ignore
        cls: Type["IMorphoBlueHyperdriveInvalidCheckpointTimeContractError"],
        data: HexBytes,
    ) -> tuple[Any, ...]:
        """Decodes error data returns from a smart contract."""
        error_abi = cast(
            ABIFunction,
            [
                item
                for item in imorphobluehyperdrive_abi
                if item.get("name") == "InvalidCheckpointTime" and item.get("type") == "error"
            ][0],
        )
        types = get_abi_input_types(error_abi)
        abi_codec = ABICodec(default_registry)
        decoded = abi_codec.decode(types, data)
        return decoded


class IMorphoBlueHyperdriveInvalidERC20BridgeContractError:
    """ContractError for InvalidERC20Bridge."""

    # @combomethod destroys return types, so we are redefining functions as both class and instance
    # pylint: disable=function-redefined

    # 4 byte error selector
    selector: str
    # error signature, i.e. CustomError(uint256,bool)
    signature: str

    # pylint: disable=useless-parent-delegation
    def __init__(
        self: "IMorphoBlueHyperdriveInvalidERC20BridgeContractError",
    ) -> None:
        self.selector = "0x2aab8bd3"
        self.signature = "InvalidERC20Bridge()"

    def decode_error_data(  # type: ignore
        self: "IMorphoBlueHyperdriveInvalidERC20BridgeContractError",
        data: HexBytes,
        # TODO: instead of returning a tuple, return a dataclass with the input names and types just like we do for functions
    ) -> tuple[Any, ...]:
        """Decodes error data returns from a smart contract."""
        error_abi = cast(
            ABIFunction,
            [
                item
                for item in imorphobluehyperdrive_abi
                if item.get("name") == "InvalidERC20Bridge" and item.get("type") == "error"
            ][0],
        )
        types = get_abi_input_types(error_abi)
        abi_codec = ABICodec(default_registry)
        decoded = abi_codec.decode(types, data)
        return decoded

    @classmethod
    def decode_error_data(  # type: ignore
        cls: Type["IMorphoBlueHyperdriveInvalidERC20BridgeContractError"],
        data: HexBytes,
    ) -> tuple[Any, ...]:
        """Decodes error data returns from a smart contract."""
        error_abi = cast(
            ABIFunction,
            [
                item
                for item in imorphobluehyperdrive_abi
                if item.get("name") == "InvalidERC20Bridge" and item.get("type") == "error"
            ][0],
        )
        types = get_abi_input_types(error_abi)
        abi_codec = ABICodec(default_registry)
        decoded = abi_codec.decode(types, data)
        return decoded


class IMorphoBlueHyperdriveInvalidEffectiveShareReservesContractError:
    """ContractError for InvalidEffectiveShareReserves."""

    # @combomethod destroys return types, so we are redefining functions as both class and instance
    # pylint: disable=function-redefined

    # 4 byte error selector
    selector: str
    # error signature, i.e. CustomError(uint256,bool)
    signature: str

    # pylint: disable=useless-parent-delegation
    def __init__(
        self: "IMorphoBlueHyperdriveInvalidEffectiveShareReservesContractError",
    ) -> None:
        self.selector = "0x85bd2ac4"
        self.signature = "InvalidEffectiveShareReserves()"

    def decode_error_data(  # type: ignore
        self: "IMorphoBlueHyperdriveInvalidEffectiveShareReservesContractError",
        data: HexBytes,
        # TODO: instead of returning a tuple, return a dataclass with the input names and types just like we do for functions
    ) -> tuple[Any, ...]:
        """Decodes error data returns from a smart contract."""
        error_abi = cast(
            ABIFunction,
            [
                item
                for item in imorphobluehyperdrive_abi
                if item.get("name") == "InvalidEffectiveShareReserves" and item.get("type") == "error"
            ][0],
        )
        types = get_abi_input_types(error_abi)
        abi_codec = ABICodec(default_registry)
        decoded = abi_codec.decode(types, data)
        return decoded

    @classmethod
    def decode_error_data(  # type: ignore
        cls: Type["IMorphoBlueHyperdriveInvalidEffectiveShareReservesContractError"],
        data: HexBytes,
    ) -> tuple[Any, ...]:
        """Decodes error data returns from a smart contract."""
        error_abi = cast(
            ABIFunction,
            [
                item
                for item in imorphobluehyperdrive_abi
                if item.get("name") == "InvalidEffectiveShareReserves" and item.get("type") == "error"
            ][0],
        )
        types = get_abi_input_types(error_abi)
        abi_codec = ABICodec(default_registry)
        decoded = abi_codec.decode(types, data)
        return decoded


class IMorphoBlueHyperdriveInvalidFeeDestinationContractError:
    """ContractError for InvalidFeeDestination."""

    # @combomethod destroys return types, so we are redefining functions as both class and instance
    # pylint: disable=function-redefined

    # 4 byte error selector
    selector: str
    # error signature, i.e. CustomError(uint256,bool)
    signature: str

    # pylint: disable=useless-parent-delegation
    def __init__(
        self: "IMorphoBlueHyperdriveInvalidFeeDestinationContractError",
    ) -> None:
        self.selector = "0x2b44eccc"
        self.signature = "InvalidFeeDestination()"

    def decode_error_data(  # type: ignore
        self: "IMorphoBlueHyperdriveInvalidFeeDestinationContractError",
        data: HexBytes,
        # TODO: instead of returning a tuple, return a dataclass with the input names and types just like we do for functions
    ) -> tuple[Any, ...]:
        """Decodes error data returns from a smart contract."""
        error_abi = cast(
            ABIFunction,
            [
                item
                for item in imorphobluehyperdrive_abi
                if item.get("name") == "InvalidFeeDestination" and item.get("type") == "error"
            ][0],
        )
        types = get_abi_input_types(error_abi)
        abi_codec = ABICodec(default_registry)
        decoded = abi_codec.decode(types, data)
        return decoded

    @classmethod
    def decode_error_data(  # type: ignore
        cls: Type["IMorphoBlueHyperdriveInvalidFeeDestinationContractError"],
        data: HexBytes,
    ) -> tuple[Any, ...]:
        """Decodes error data returns from a smart contract."""
        error_abi = cast(
            ABIFunction,
            [
                item
                for item in imorphobluehyperdrive_abi
                if item.get("name") == "InvalidFeeDestination" and item.get("type") == "error"
            ][0],
        )
        types = get_abi_input_types(error_abi)
        abi_codec = ABICodec(default_registry)
        decoded = abi_codec.decode(types, data)
        return decoded


class IMorphoBlueHyperdriveInvalidInitialVaultSharePriceContractError:
    """ContractError for InvalidInitialVaultSharePrice."""

    # @combomethod destroys return types, so we are redefining functions as both class and instance
    # pylint: disable=function-redefined

    # 4 byte error selector
    selector: str
    # error signature, i.e. CustomError(uint256,bool)
    signature: str

    # pylint: disable=useless-parent-delegation
    def __init__(
        self: "IMorphoBlueHyperdriveInvalidInitialVaultSharePriceContractError",
    ) -> None:
        self.selector = "0x094b19ad"
        self.signature = "InvalidInitialVaultSharePrice()"

    def decode_error_data(  # type: ignore
        self: "IMorphoBlueHyperdriveInvalidInitialVaultSharePriceContractError",
        data: HexBytes,
        # TODO: instead of returning a tuple, return a dataclass with the input names and types just like we do for functions
    ) -> tuple[Any, ...]:
        """Decodes error data returns from a smart contract."""
        error_abi = cast(
            ABIFunction,
            [
                item
                for item in imorphobluehyperdrive_abi
                if item.get("name") == "InvalidInitialVaultSharePrice" and item.get("type") == "error"
            ][0],
        )
        types = get_abi_input_types(error_abi)
        abi_codec = ABICodec(default_registry)
        decoded = abi_codec.decode(types, data)
        return decoded

    @classmethod
    def decode_error_data(  # type: ignore
        cls: Type["IMorphoBlueHyperdriveInvalidInitialVaultSharePriceContractError"],
        data: HexBytes,
    ) -> tuple[Any, ...]:
        """Decodes error data returns from a smart contract."""
        error_abi = cast(
            ABIFunction,
            [
                item
                for item in imorphobluehyperdrive_abi
                if item.get("name") == "InvalidInitialVaultSharePrice" and item.get("type") == "error"
            ][0],
        )
        types = get_abi_input_types(error_abi)
        abi_codec = ABICodec(default_registry)
        decoded = abi_codec.decode(types, data)
        return decoded


class IMorphoBlueHyperdriveInvalidLPSharePriceContractError:
    """ContractError for InvalidLPSharePrice."""

    # @combomethod destroys return types, so we are redefining functions as both class and instance
    # pylint: disable=function-redefined

    # 4 byte error selector
    selector: str
    # error signature, i.e. CustomError(uint256,bool)
    signature: str

    # pylint: disable=useless-parent-delegation
    def __init__(
        self: "IMorphoBlueHyperdriveInvalidLPSharePriceContractError",
    ) -> None:
        self.selector = "0xabeba7ee"
        self.signature = "InvalidLPSharePrice()"

    def decode_error_data(  # type: ignore
        self: "IMorphoBlueHyperdriveInvalidLPSharePriceContractError",
        data: HexBytes,
        # TODO: instead of returning a tuple, return a dataclass with the input names and types just like we do for functions
    ) -> tuple[Any, ...]:
        """Decodes error data returns from a smart contract."""
        error_abi = cast(
            ABIFunction,
            [
                item
                for item in imorphobluehyperdrive_abi
                if item.get("name") == "InvalidLPSharePrice" and item.get("type") == "error"
            ][0],
        )
        types = get_abi_input_types(error_abi)
        abi_codec = ABICodec(default_registry)
        decoded = abi_codec.decode(types, data)
        return decoded

    @classmethod
    def decode_error_data(  # type: ignore
        cls: Type["IMorphoBlueHyperdriveInvalidLPSharePriceContractError"],
        data: HexBytes,
    ) -> tuple[Any, ...]:
        """Decodes error data returns from a smart contract."""
        error_abi = cast(
            ABIFunction,
            [
                item
                for item in imorphobluehyperdrive_abi
                if item.get("name") == "InvalidLPSharePrice" and item.get("type") == "error"
            ][0],
        )
        types = get_abi_input_types(error_abi)
        abi_codec = ABICodec(default_registry)
        decoded = abi_codec.decode(types, data)
        return decoded


class IMorphoBlueHyperdriveInvalidPresentValueContractError:
    """ContractError for InvalidPresentValue."""

    # @combomethod destroys return types, so we are redefining functions as both class and instance
    # pylint: disable=function-redefined

    # 4 byte error selector
    selector: str
    # error signature, i.e. CustomError(uint256,bool)
    signature: str

    # pylint: disable=useless-parent-delegation
    def __init__(
        self: "IMorphoBlueHyperdriveInvalidPresentValueContractError",
    ) -> None:
        self.selector = "0xaa2c6516"
        self.signature = "InvalidPresentValue()"

    def decode_error_data(  # type: ignore
        self: "IMorphoBlueHyperdriveInvalidPresentValueContractError",
        data: HexBytes,
        # TODO: instead of returning a tuple, return a dataclass with the input names and types just like we do for functions
    ) -> tuple[Any, ...]:
        """Decodes error data returns from a smart contract."""
        error_abi = cast(
            ABIFunction,
            [
                item
                for item in imorphobluehyperdrive_abi
                if item.get("name") == "InvalidPresentValue" and item.get("type") == "error"
            ][0],
        )
        types = get_abi_input_types(error_abi)
        abi_codec = ABICodec(default_registry)
        decoded = abi_codec.decode(types, data)
        return decoded

    @classmethod
    def decode_error_data(  # type: ignore
        cls: Type["IMorphoBlueHyperdriveInvalidPresentValueContractError"],
        data: HexBytes,
    ) -> tuple[Any, ...]:
        """Decodes error data returns from a smart contract."""
        error_abi = cast(
            ABIFunction,
            [
                item
                for item in imorphobluehyperdrive_abi
                if item.get("name") == "InvalidPresentValue" and item.get("type") == "error"
            ][0],
        )
        types = get_abi_input_types(error_abi)
        abi_codec = ABICodec(default_registry)
        decoded = abi_codec.decode(types, data)
        return decoded


class IMorphoBlueHyperdriveInvalidSignatureContractError:
    """ContractError for InvalidSignature."""

    # @combomethod destroys return types, so we are redefining functions as both class and instance
    # pylint: disable=function-redefined

    # 4 byte error selector
    selector: str
    # error signature, i.e. CustomError(uint256,bool)
    signature: str

    # pylint: disable=useless-parent-delegation
    def __init__(
        self: "IMorphoBlueHyperdriveInvalidSignatureContractError",
    ) -> None:
        self.selector = "0x8baa579f"
        self.signature = "InvalidSignature()"

    def decode_error_data(  # type: ignore
        self: "IMorphoBlueHyperdriveInvalidSignatureContractError",
        data: HexBytes,
        # TODO: instead of returning a tuple, return a dataclass with the input names and types just like we do for functions
    ) -> tuple[Any, ...]:
        """Decodes error data returns from a smart contract."""
        error_abi = cast(
            ABIFunction,
            [
                item
                for item in imorphobluehyperdrive_abi
                if item.get("name") == "InvalidSignature" and item.get("type") == "error"
            ][0],
        )
        types = get_abi_input_types(error_abi)
        abi_codec = ABICodec(default_registry)
        decoded = abi_codec.decode(types, data)
        return decoded

    @classmethod
    def decode_error_data(  # type: ignore
        cls: Type["IMorphoBlueHyperdriveInvalidSignatureContractError"],
        data: HexBytes,
    ) -> tuple[Any, ...]:
        """Decodes error data returns from a smart contract."""
        error_abi = cast(
            ABIFunction,
            [
                item
                for item in imorphobluehyperdrive_abi
                if item.get("name") == "InvalidSignature" and item.get("type") == "error"
            ][0],
        )
        types = get_abi_input_types(error_abi)
        abi_codec = ABICodec(default_registry)
        decoded = abi_codec.decode(types, data)
        return decoded


class IMorphoBlueHyperdriveInvalidTimestampContractError:
    """ContractError for InvalidTimestamp."""

    # @combomethod destroys return types, so we are redefining functions as both class and instance
    # pylint: disable=function-redefined

    # 4 byte error selector
    selector: str
    # error signature, i.e. CustomError(uint256,bool)
    signature: str

    # pylint: disable=useless-parent-delegation
    def __init__(
        self: "IMorphoBlueHyperdriveInvalidTimestampContractError",
    ) -> None:
        self.selector = "0xb7d09497"
        self.signature = "InvalidTimestamp()"

    def decode_error_data(  # type: ignore
        self: "IMorphoBlueHyperdriveInvalidTimestampContractError",
        data: HexBytes,
        # TODO: instead of returning a tuple, return a dataclass with the input names and types just like we do for functions
    ) -> tuple[Any, ...]:
        """Decodes error data returns from a smart contract."""
        error_abi = cast(
            ABIFunction,
            [
                item
                for item in imorphobluehyperdrive_abi
                if item.get("name") == "InvalidTimestamp" and item.get("type") == "error"
            ][0],
        )
        types = get_abi_input_types(error_abi)
        abi_codec = ABICodec(default_registry)
        decoded = abi_codec.decode(types, data)
        return decoded

    @classmethod
    def decode_error_data(  # type: ignore
        cls: Type["IMorphoBlueHyperdriveInvalidTimestampContractError"],
        data: HexBytes,
    ) -> tuple[Any, ...]:
        """Decodes error data returns from a smart contract."""
        error_abi = cast(
            ABIFunction,
            [
                item
                for item in imorphobluehyperdrive_abi
                if item.get("name") == "InvalidTimestamp" and item.get("type") == "error"
            ][0],
        )
        types = get_abi_input_types(error_abi)
        abi_codec = ABICodec(default_registry)
        decoded = abi_codec.decode(types, data)
        return decoded


class IMorphoBlueHyperdriveLnInvalidInputContractError:
    """ContractError for LnInvalidInput."""

    # @combomethod destroys return types, so we are redefining functions as both class and instance
    # pylint: disable=function-redefined

    # 4 byte error selector
    selector: str
    # error signature, i.e. CustomError(uint256,bool)
    signature: str

    # pylint: disable=useless-parent-delegation
    def __init__(
        self: "IMorphoBlueHyperdriveLnInvalidInputContractError",
    ) -> None:
        self.selector = "0xe61b4975"
        self.signature = "LnInvalidInput()"

    def decode_error_data(  # type: ignore
        self: "IMorphoBlueHyperdriveLnInvalidInputContractError",
        data: HexBytes,
        # TODO: instead of returning a tuple, return a dataclass with the input names and types just like we do for functions
    ) -> tuple[Any, ...]:
        """Decodes error data returns from a smart contract."""
        error_abi = cast(
            ABIFunction,
            [
                item
                for item in imorphobluehyperdrive_abi
                if item.get("name") == "LnInvalidInput" and item.get("type") == "error"
            ][0],
        )
        types = get_abi_input_types(error_abi)
        abi_codec = ABICodec(default_registry)
        decoded = abi_codec.decode(types, data)
        return decoded

    @classmethod
    def decode_error_data(  # type: ignore
        cls: Type["IMorphoBlueHyperdriveLnInvalidInputContractError"],
        data: HexBytes,
    ) -> tuple[Any, ...]:
        """Decodes error data returns from a smart contract."""
        error_abi = cast(
            ABIFunction,
            [
                item
                for item in imorphobluehyperdrive_abi
                if item.get("name") == "LnInvalidInput" and item.get("type") == "error"
            ][0],
        )
        types = get_abi_input_types(error_abi)
        abi_codec = ABICodec(default_registry)
        decoded = abi_codec.decode(types, data)
        return decoded


class IMorphoBlueHyperdriveMinimumSharePriceContractError:
    """ContractError for MinimumSharePrice."""

    # @combomethod destroys return types, so we are redefining functions as both class and instance
    # pylint: disable=function-redefined

    # 4 byte error selector
    selector: str
    # error signature, i.e. CustomError(uint256,bool)
    signature: str

    # pylint: disable=useless-parent-delegation
    def __init__(
        self: "IMorphoBlueHyperdriveMinimumSharePriceContractError",
    ) -> None:
        self.selector = "0x42af972b"
        self.signature = "MinimumSharePrice()"

    def decode_error_data(  # type: ignore
        self: "IMorphoBlueHyperdriveMinimumSharePriceContractError",
        data: HexBytes,
        # TODO: instead of returning a tuple, return a dataclass with the input names and types just like we do for functions
    ) -> tuple[Any, ...]:
        """Decodes error data returns from a smart contract."""
        error_abi = cast(
            ABIFunction,
            [
                item
                for item in imorphobluehyperdrive_abi
                if item.get("name") == "MinimumSharePrice" and item.get("type") == "error"
            ][0],
        )
        types = get_abi_input_types(error_abi)
        abi_codec = ABICodec(default_registry)
        decoded = abi_codec.decode(types, data)
        return decoded

    @classmethod
    def decode_error_data(  # type: ignore
        cls: Type["IMorphoBlueHyperdriveMinimumSharePriceContractError"],
        data: HexBytes,
    ) -> tuple[Any, ...]:
        """Decodes error data returns from a smart contract."""
        error_abi = cast(
            ABIFunction,
            [
                item
                for item in imorphobluehyperdrive_abi
                if item.get("name") == "MinimumSharePrice" and item.get("type") == "error"
            ][0],
        )
        types = get_abi_input_types(error_abi)
        abi_codec = ABICodec(default_registry)
        decoded = abi_codec.decode(types, data)
        return decoded


class IMorphoBlueHyperdriveMinimumTransactionAmountContractError:
    """ContractError for MinimumTransactionAmount."""

    # @combomethod destroys return types, so we are redefining functions as both class and instance
    # pylint: disable=function-redefined

    # 4 byte error selector
    selector: str
    # error signature, i.e. CustomError(uint256,bool)
    signature: str

    # pylint: disable=useless-parent-delegation
    def __init__(
        self: "IMorphoBlueHyperdriveMinimumTransactionAmountContractError",
    ) -> None:
        self.selector = "0x423bbb46"
        self.signature = "MinimumTransactionAmount()"

    def decode_error_data(  # type: ignore
        self: "IMorphoBlueHyperdriveMinimumTransactionAmountContractError",
        data: HexBytes,
        # TODO: instead of returning a tuple, return a dataclass with the input names and types just like we do for functions
    ) -> tuple[Any, ...]:
        """Decodes error data returns from a smart contract."""
        error_abi = cast(
            ABIFunction,
            [
                item
                for item in imorphobluehyperdrive_abi
                if item.get("name") == "MinimumTransactionAmount" and item.get("type") == "error"
            ][0],
        )
        types = get_abi_input_types(error_abi)
        abi_codec = ABICodec(default_registry)
        decoded = abi_codec.decode(types, data)
        return decoded

    @classmethod
    def decode_error_data(  # type: ignore
        cls: Type["IMorphoBlueHyperdriveMinimumTransactionAmountContractError"],
        data: HexBytes,
    ) -> tuple[Any, ...]:
        """Decodes error data returns from a smart contract."""
        error_abi = cast(
            ABIFunction,
            [
                item
                for item in imorphobluehyperdrive_abi
                if item.get("name") == "MinimumTransactionAmount" and item.get("type") == "error"
            ][0],
        )
        types = get_abi_input_types(error_abi)
        abi_codec = ABICodec(default_registry)
        decoded = abi_codec.decode(types, data)
        return decoded


class IMorphoBlueHyperdriveNotPayableContractError:
    """ContractError for NotPayable."""

    # @combomethod destroys return types, so we are redefining functions as both class and instance
    # pylint: disable=function-redefined

    # 4 byte error selector
    selector: str
    # error signature, i.e. CustomError(uint256,bool)
    signature: str

    # pylint: disable=useless-parent-delegation
    def __init__(
        self: "IMorphoBlueHyperdriveNotPayableContractError",
    ) -> None:
        self.selector = "0x1574f9f3"
        self.signature = "NotPayable()"

    def decode_error_data(  # type: ignore
        self: "IMorphoBlueHyperdriveNotPayableContractError",
        data: HexBytes,
        # TODO: instead of returning a tuple, return a dataclass with the input names and types just like we do for functions
    ) -> tuple[Any, ...]:
        """Decodes error data returns from a smart contract."""
        error_abi = cast(
            ABIFunction,
            [
                item
                for item in imorphobluehyperdrive_abi
                if item.get("name") == "NotPayable" and item.get("type") == "error"
            ][0],
        )
        types = get_abi_input_types(error_abi)
        abi_codec = ABICodec(default_registry)
        decoded = abi_codec.decode(types, data)
        return decoded

    @classmethod
    def decode_error_data(  # type: ignore
        cls: Type["IMorphoBlueHyperdriveNotPayableContractError"],
        data: HexBytes,
    ) -> tuple[Any, ...]:
        """Decodes error data returns from a smart contract."""
        error_abi = cast(
            ABIFunction,
            [
                item
                for item in imorphobluehyperdrive_abi
                if item.get("name") == "NotPayable" and item.get("type") == "error"
            ][0],
        )
        types = get_abi_input_types(error_abi)
        abi_codec = ABICodec(default_registry)
        decoded = abi_codec.decode(types, data)
        return decoded


class IMorphoBlueHyperdriveOutputLimitContractError:
    """ContractError for OutputLimit."""

    # @combomethod destroys return types, so we are redefining functions as both class and instance
    # pylint: disable=function-redefined

    # 4 byte error selector
    selector: str
    # error signature, i.e. CustomError(uint256,bool)
    signature: str

    # pylint: disable=useless-parent-delegation
    def __init__(
        self: "IMorphoBlueHyperdriveOutputLimitContractError",
    ) -> None:
        self.selector = "0xc9726517"
        self.signature = "OutputLimit()"

    def decode_error_data(  # type: ignore
        self: "IMorphoBlueHyperdriveOutputLimitContractError",
        data: HexBytes,
        # TODO: instead of returning a tuple, return a dataclass with the input names and types just like we do for functions
    ) -> tuple[Any, ...]:
        """Decodes error data returns from a smart contract."""
        error_abi = cast(
            ABIFunction,
            [
                item
                for item in imorphobluehyperdrive_abi
                if item.get("name") == "OutputLimit" and item.get("type") == "error"
            ][0],
        )
        types = get_abi_input_types(error_abi)
        abi_codec = ABICodec(default_registry)
        decoded = abi_codec.decode(types, data)
        return decoded

    @classmethod
    def decode_error_data(  # type: ignore
        cls: Type["IMorphoBlueHyperdriveOutputLimitContractError"],
        data: HexBytes,
    ) -> tuple[Any, ...]:
        """Decodes error data returns from a smart contract."""
        error_abi = cast(
            ABIFunction,
            [
                item
                for item in imorphobluehyperdrive_abi
                if item.get("name") == "OutputLimit" and item.get("type") == "error"
            ][0],
        )
        types = get_abi_input_types(error_abi)
        abi_codec = ABICodec(default_registry)
        decoded = abi_codec.decode(types, data)
        return decoded


class IMorphoBlueHyperdrivePoolAlreadyInitializedContractError:
    """ContractError for PoolAlreadyInitialized."""

    # @combomethod destroys return types, so we are redefining functions as both class and instance
    # pylint: disable=function-redefined

    # 4 byte error selector
    selector: str
    # error signature, i.e. CustomError(uint256,bool)
    signature: str

    # pylint: disable=useless-parent-delegation
    def __init__(
        self: "IMorphoBlueHyperdrivePoolAlreadyInitializedContractError",
    ) -> None:
        self.selector = "0x7983c051"
        self.signature = "PoolAlreadyInitialized()"

    def decode_error_data(  # type: ignore
        self: "IMorphoBlueHyperdrivePoolAlreadyInitializedContractError",
        data: HexBytes,
        # TODO: instead of returning a tuple, return a dataclass with the input names and types just like we do for functions
    ) -> tuple[Any, ...]:
        """Decodes error data returns from a smart contract."""
        error_abi = cast(
            ABIFunction,
            [
                item
                for item in imorphobluehyperdrive_abi
                if item.get("name") == "PoolAlreadyInitialized" and item.get("type") == "error"
            ][0],
        )
        types = get_abi_input_types(error_abi)
        abi_codec = ABICodec(default_registry)
        decoded = abi_codec.decode(types, data)
        return decoded

    @classmethod
    def decode_error_data(  # type: ignore
        cls: Type["IMorphoBlueHyperdrivePoolAlreadyInitializedContractError"],
        data: HexBytes,
    ) -> tuple[Any, ...]:
        """Decodes error data returns from a smart contract."""
        error_abi = cast(
            ABIFunction,
            [
                item
                for item in imorphobluehyperdrive_abi
                if item.get("name") == "PoolAlreadyInitialized" and item.get("type") == "error"
            ][0],
        )
        types = get_abi_input_types(error_abi)
        abi_codec = ABICodec(default_registry)
        decoded = abi_codec.decode(types, data)
        return decoded


class IMorphoBlueHyperdrivePoolIsPausedContractError:
    """ContractError for PoolIsPaused."""

    # @combomethod destroys return types, so we are redefining functions as both class and instance
    # pylint: disable=function-redefined

    # 4 byte error selector
    selector: str
    # error signature, i.e. CustomError(uint256,bool)
    signature: str

    # pylint: disable=useless-parent-delegation
    def __init__(
        self: "IMorphoBlueHyperdrivePoolIsPausedContractError",
    ) -> None:
        self.selector = "0x21081abf"
        self.signature = "PoolIsPaused()"

    def decode_error_data(  # type: ignore
        self: "IMorphoBlueHyperdrivePoolIsPausedContractError",
        data: HexBytes,
        # TODO: instead of returning a tuple, return a dataclass with the input names and types just like we do for functions
    ) -> tuple[Any, ...]:
        """Decodes error data returns from a smart contract."""
        error_abi = cast(
            ABIFunction,
            [
                item
                for item in imorphobluehyperdrive_abi
                if item.get("name") == "PoolIsPaused" and item.get("type") == "error"
            ][0],
        )
        types = get_abi_input_types(error_abi)
        abi_codec = ABICodec(default_registry)
        decoded = abi_codec.decode(types, data)
        return decoded

    @classmethod
    def decode_error_data(  # type: ignore
        cls: Type["IMorphoBlueHyperdrivePoolIsPausedContractError"],
        data: HexBytes,
    ) -> tuple[Any, ...]:
        """Decodes error data returns from a smart contract."""
        error_abi = cast(
            ABIFunction,
            [
                item
                for item in imorphobluehyperdrive_abi
                if item.get("name") == "PoolIsPaused" and item.get("type") == "error"
            ][0],
        )
        types = get_abi_input_types(error_abi)
        abi_codec = ABICodec(default_registry)
        decoded = abi_codec.decode(types, data)
        return decoded


class IMorphoBlueHyperdriveRestrictedZeroAddressContractError:
    """ContractError for RestrictedZeroAddress."""

    # @combomethod destroys return types, so we are redefining functions as both class and instance
    # pylint: disable=function-redefined

    # 4 byte error selector
    selector: str
    # error signature, i.e. CustomError(uint256,bool)
    signature: str

    # pylint: disable=useless-parent-delegation
    def __init__(
        self: "IMorphoBlueHyperdriveRestrictedZeroAddressContractError",
    ) -> None:
        self.selector = "0xf0dd15fd"
        self.signature = "RestrictedZeroAddress()"

    def decode_error_data(  # type: ignore
        self: "IMorphoBlueHyperdriveRestrictedZeroAddressContractError",
        data: HexBytes,
        # TODO: instead of returning a tuple, return a dataclass with the input names and types just like we do for functions
    ) -> tuple[Any, ...]:
        """Decodes error data returns from a smart contract."""
        error_abi = cast(
            ABIFunction,
            [
                item
                for item in imorphobluehyperdrive_abi
                if item.get("name") == "RestrictedZeroAddress" and item.get("type") == "error"
            ][0],
        )
        types = get_abi_input_types(error_abi)
        abi_codec = ABICodec(default_registry)
        decoded = abi_codec.decode(types, data)
        return decoded

    @classmethod
    def decode_error_data(  # type: ignore
        cls: Type["IMorphoBlueHyperdriveRestrictedZeroAddressContractError"],
        data: HexBytes,
    ) -> tuple[Any, ...]:
        """Decodes error data returns from a smart contract."""
        error_abi = cast(
            ABIFunction,
            [
                item
                for item in imorphobluehyperdrive_abi
                if item.get("name") == "RestrictedZeroAddress" and item.get("type") == "error"
            ][0],
        )
        types = get_abi_input_types(error_abi)
        abi_codec = ABICodec(default_registry)
        decoded = abi_codec.decode(types, data)
        return decoded


class IMorphoBlueHyperdriveReturnDataContractError:
    """ContractError for ReturnData."""

    # @combomethod destroys return types, so we are redefining functions as both class and instance
    # pylint: disable=function-redefined

    # 4 byte error selector
    selector: str
    # error signature, i.e. CustomError(uint256,bool)
    signature: str

    # pylint: disable=useless-parent-delegation
    def __init__(
        self: "IMorphoBlueHyperdriveReturnDataContractError",
    ) -> None:
        self.selector = "0xdcc81126"
        self.signature = "ReturnData(bytes)"

    def decode_error_data(  # type: ignore
        self: "IMorphoBlueHyperdriveReturnDataContractError",
        data: HexBytes,
        # TODO: instead of returning a tuple, return a dataclass with the input names and types just like we do for functions
    ) -> tuple[Any, ...]:
        """Decodes error data returns from a smart contract."""
        error_abi = cast(
            ABIFunction,
            [
                item
                for item in imorphobluehyperdrive_abi
                if item.get("name") == "ReturnData" and item.get("type") == "error"
            ][0],
        )
        types = get_abi_input_types(error_abi)
        abi_codec = ABICodec(default_registry)
        decoded = abi_codec.decode(types, data)
        return decoded

    @classmethod
    def decode_error_data(  # type: ignore
        cls: Type["IMorphoBlueHyperdriveReturnDataContractError"],
        data: HexBytes,
    ) -> tuple[Any, ...]:
        """Decodes error data returns from a smart contract."""
        error_abi = cast(
            ABIFunction,
            [
                item
                for item in imorphobluehyperdrive_abi
                if item.get("name") == "ReturnData" and item.get("type") == "error"
            ][0],
        )
        types = get_abi_input_types(error_abi)
        abi_codec = ABICodec(default_registry)
        decoded = abi_codec.decode(types, data)
        return decoded


class IMorphoBlueHyperdriveSweepFailedContractError:
    """ContractError for SweepFailed."""

    # @combomethod destroys return types, so we are redefining functions as both class and instance
    # pylint: disable=function-redefined

    # 4 byte error selector
    selector: str
    # error signature, i.e. CustomError(uint256,bool)
    signature: str

    # pylint: disable=useless-parent-delegation
    def __init__(
        self: "IMorphoBlueHyperdriveSweepFailedContractError",
    ) -> None:
        self.selector = "0x9eec2ff8"
        self.signature = "SweepFailed()"

    def decode_error_data(  # type: ignore
        self: "IMorphoBlueHyperdriveSweepFailedContractError",
        data: HexBytes,
        # TODO: instead of returning a tuple, return a dataclass with the input names and types just like we do for functions
    ) -> tuple[Any, ...]:
        """Decodes error data returns from a smart contract."""
        error_abi = cast(
            ABIFunction,
            [
                item
                for item in imorphobluehyperdrive_abi
                if item.get("name") == "SweepFailed" and item.get("type") == "error"
            ][0],
        )
        types = get_abi_input_types(error_abi)
        abi_codec = ABICodec(default_registry)
        decoded = abi_codec.decode(types, data)
        return decoded

    @classmethod
    def decode_error_data(  # type: ignore
        cls: Type["IMorphoBlueHyperdriveSweepFailedContractError"],
        data: HexBytes,
    ) -> tuple[Any, ...]:
        """Decodes error data returns from a smart contract."""
        error_abi = cast(
            ABIFunction,
            [
                item
                for item in imorphobluehyperdrive_abi
                if item.get("name") == "SweepFailed" and item.get("type") == "error"
            ][0],
        )
        types = get_abi_input_types(error_abi)
        abi_codec = ABICodec(default_registry)
        decoded = abi_codec.decode(types, data)
        return decoded


class IMorphoBlueHyperdriveTransferFailedContractError:
    """ContractError for TransferFailed."""

    # @combomethod destroys return types, so we are redefining functions as both class and instance
    # pylint: disable=function-redefined

    # 4 byte error selector
    selector: str
    # error signature, i.e. CustomError(uint256,bool)
    signature: str

    # pylint: disable=useless-parent-delegation
    def __init__(
        self: "IMorphoBlueHyperdriveTransferFailedContractError",
    ) -> None:
        self.selector = "0x90b8ec18"
        self.signature = "TransferFailed()"

    def decode_error_data(  # type: ignore
        self: "IMorphoBlueHyperdriveTransferFailedContractError",
        data: HexBytes,
        # TODO: instead of returning a tuple, return a dataclass with the input names and types just like we do for functions
    ) -> tuple[Any, ...]:
        """Decodes error data returns from a smart contract."""
        error_abi = cast(
            ABIFunction,
            [
                item
                for item in imorphobluehyperdrive_abi
                if item.get("name") == "TransferFailed" and item.get("type") == "error"
            ][0],
        )
        types = get_abi_input_types(error_abi)
        abi_codec = ABICodec(default_registry)
        decoded = abi_codec.decode(types, data)
        return decoded

    @classmethod
    def decode_error_data(  # type: ignore
        cls: Type["IMorphoBlueHyperdriveTransferFailedContractError"],
        data: HexBytes,
    ) -> tuple[Any, ...]:
        """Decodes error data returns from a smart contract."""
        error_abi = cast(
            ABIFunction,
            [
                item
                for item in imorphobluehyperdrive_abi
                if item.get("name") == "TransferFailed" and item.get("type") == "error"
            ][0],
        )
        types = get_abi_input_types(error_abi)
        abi_codec = ABICodec(default_registry)
        decoded = abi_codec.decode(types, data)
        return decoded


class IMorphoBlueHyperdriveUnauthorizedContractError:
    """ContractError for Unauthorized."""

    # @combomethod destroys return types, so we are redefining functions as both class and instance
    # pylint: disable=function-redefined

    # 4 byte error selector
    selector: str
    # error signature, i.e. CustomError(uint256,bool)
    signature: str

    # pylint: disable=useless-parent-delegation
    def __init__(
        self: "IMorphoBlueHyperdriveUnauthorizedContractError",
    ) -> None:
        self.selector = "0x82b42900"
        self.signature = "Unauthorized()"

    def decode_error_data(  # type: ignore
        self: "IMorphoBlueHyperdriveUnauthorizedContractError",
        data: HexBytes,
        # TODO: instead of returning a tuple, return a dataclass with the input names and types just like we do for functions
    ) -> tuple[Any, ...]:
        """Decodes error data returns from a smart contract."""
        error_abi = cast(
            ABIFunction,
            [
                item
                for item in imorphobluehyperdrive_abi
                if item.get("name") == "Unauthorized" and item.get("type") == "error"
            ][0],
        )
        types = get_abi_input_types(error_abi)
        abi_codec = ABICodec(default_registry)
        decoded = abi_codec.decode(types, data)
        return decoded

    @classmethod
    def decode_error_data(  # type: ignore
        cls: Type["IMorphoBlueHyperdriveUnauthorizedContractError"],
        data: HexBytes,
    ) -> tuple[Any, ...]:
        """Decodes error data returns from a smart contract."""
        error_abi = cast(
            ABIFunction,
            [
                item
                for item in imorphobluehyperdrive_abi
                if item.get("name") == "Unauthorized" and item.get("type") == "error"
            ][0],
        )
        types = get_abi_input_types(error_abi)
        abi_codec = ABICodec(default_registry)
        decoded = abi_codec.decode(types, data)
        return decoded


class IMorphoBlueHyperdriveUnexpectedSuccessContractError:
    """ContractError for UnexpectedSuccess."""

    # @combomethod destroys return types, so we are redefining functions as both class and instance
    # pylint: disable=function-redefined

    # 4 byte error selector
    selector: str
    # error signature, i.e. CustomError(uint256,bool)
    signature: str

    # pylint: disable=useless-parent-delegation
    def __init__(
        self: "IMorphoBlueHyperdriveUnexpectedSuccessContractError",
    ) -> None:
        self.selector = "0x8bb0a34b"
        self.signature = "UnexpectedSuccess()"

    def decode_error_data(  # type: ignore
        self: "IMorphoBlueHyperdriveUnexpectedSuccessContractError",
        data: HexBytes,
        # TODO: instead of returning a tuple, return a dataclass with the input names and types just like we do for functions
    ) -> tuple[Any, ...]:
        """Decodes error data returns from a smart contract."""
        error_abi = cast(
            ABIFunction,
            [
                item
                for item in imorphobluehyperdrive_abi
                if item.get("name") == "UnexpectedSuccess" and item.get("type") == "error"
            ][0],
        )
        types = get_abi_input_types(error_abi)
        abi_codec = ABICodec(default_registry)
        decoded = abi_codec.decode(types, data)
        return decoded

    @classmethod
    def decode_error_data(  # type: ignore
        cls: Type["IMorphoBlueHyperdriveUnexpectedSuccessContractError"],
        data: HexBytes,
    ) -> tuple[Any, ...]:
        """Decodes error data returns from a smart contract."""
        error_abi = cast(
            ABIFunction,
            [
                item
                for item in imorphobluehyperdrive_abi
                if item.get("name") == "UnexpectedSuccess" and item.get("type") == "error"
            ][0],
        )
        types = get_abi_input_types(error_abi)
        abi_codec = ABICodec(default_registry)
        decoded = abi_codec.decode(types, data)
        return decoded


class IMorphoBlueHyperdriveUnsafeCastToInt128ContractError:
    """ContractError for UnsafeCastToInt128."""

    # @combomethod destroys return types, so we are redefining functions as both class and instance
    # pylint: disable=function-redefined

    # 4 byte error selector
    selector: str
    # error signature, i.e. CustomError(uint256,bool)
    signature: str

    # pylint: disable=useless-parent-delegation
    def __init__(
        self: "IMorphoBlueHyperdriveUnsafeCastToInt128ContractError",
    ) -> None:
        self.selector = "0xa5353be5"
        self.signature = "UnsafeCastToInt128()"

    def decode_error_data(  # type: ignore
        self: "IMorphoBlueHyperdriveUnsafeCastToInt128ContractError",
        data: HexBytes,
        # TODO: instead of returning a tuple, return a dataclass with the input names and types just like we do for functions
    ) -> tuple[Any, ...]:
        """Decodes error data returns from a smart contract."""
        error_abi = cast(
            ABIFunction,
            [
                item
                for item in imorphobluehyperdrive_abi
                if item.get("name") == "UnsafeCastToInt128" and item.get("type") == "error"
            ][0],
        )
        types = get_abi_input_types(error_abi)
        abi_codec = ABICodec(default_registry)
        decoded = abi_codec.decode(types, data)
        return decoded

    @classmethod
    def decode_error_data(  # type: ignore
        cls: Type["IMorphoBlueHyperdriveUnsafeCastToInt128ContractError"],
        data: HexBytes,
    ) -> tuple[Any, ...]:
        """Decodes error data returns from a smart contract."""
        error_abi = cast(
            ABIFunction,
            [
                item
                for item in imorphobluehyperdrive_abi
                if item.get("name") == "UnsafeCastToInt128" and item.get("type") == "error"
            ][0],
        )
        types = get_abi_input_types(error_abi)
        abi_codec = ABICodec(default_registry)
        decoded = abi_codec.decode(types, data)
        return decoded


class IMorphoBlueHyperdriveUnsafeCastToInt256ContractError:
    """ContractError for UnsafeCastToInt256."""

    # @combomethod destroys return types, so we are redefining functions as both class and instance
    # pylint: disable=function-redefined

    # 4 byte error selector
    selector: str
    # error signature, i.e. CustomError(uint256,bool)
    signature: str

    # pylint: disable=useless-parent-delegation
    def __init__(
        self: "IMorphoBlueHyperdriveUnsafeCastToInt256ContractError",
    ) -> None:
        self.selector = "0x72dd4e02"
        self.signature = "UnsafeCastToInt256()"

    def decode_error_data(  # type: ignore
        self: "IMorphoBlueHyperdriveUnsafeCastToInt256ContractError",
        data: HexBytes,
        # TODO: instead of returning a tuple, return a dataclass with the input names and types just like we do for functions
    ) -> tuple[Any, ...]:
        """Decodes error data returns from a smart contract."""
        error_abi = cast(
            ABIFunction,
            [
                item
                for item in imorphobluehyperdrive_abi
                if item.get("name") == "UnsafeCastToInt256" and item.get("type") == "error"
            ][0],
        )
        types = get_abi_input_types(error_abi)
        abi_codec = ABICodec(default_registry)
        decoded = abi_codec.decode(types, data)
        return decoded

    @classmethod
    def decode_error_data(  # type: ignore
        cls: Type["IMorphoBlueHyperdriveUnsafeCastToInt256ContractError"],
        data: HexBytes,
    ) -> tuple[Any, ...]:
        """Decodes error data returns from a smart contract."""
        error_abi = cast(
            ABIFunction,
            [
                item
                for item in imorphobluehyperdrive_abi
                if item.get("name") == "UnsafeCastToInt256" and item.get("type") == "error"
            ][0],
        )
        types = get_abi_input_types(error_abi)
        abi_codec = ABICodec(default_registry)
        decoded = abi_codec.decode(types, data)
        return decoded


class IMorphoBlueHyperdriveUnsafeCastToUint112ContractError:
    """ContractError for UnsafeCastToUint112."""

    # @combomethod destroys return types, so we are redefining functions as both class and instance
    # pylint: disable=function-redefined

    # 4 byte error selector
    selector: str
    # error signature, i.e. CustomError(uint256,bool)
    signature: str

    # pylint: disable=useless-parent-delegation
    def __init__(
        self: "IMorphoBlueHyperdriveUnsafeCastToUint112ContractError",
    ) -> None:
        self.selector = "0x10d62a2e"
        self.signature = "UnsafeCastToUint112()"

    def decode_error_data(  # type: ignore
        self: "IMorphoBlueHyperdriveUnsafeCastToUint112ContractError",
        data: HexBytes,
        # TODO: instead of returning a tuple, return a dataclass with the input names and types just like we do for functions
    ) -> tuple[Any, ...]:
        """Decodes error data returns from a smart contract."""
        error_abi = cast(
            ABIFunction,
            [
                item
                for item in imorphobluehyperdrive_abi
                if item.get("name") == "UnsafeCastToUint112" and item.get("type") == "error"
            ][0],
        )
        types = get_abi_input_types(error_abi)
        abi_codec = ABICodec(default_registry)
        decoded = abi_codec.decode(types, data)
        return decoded

    @classmethod
    def decode_error_data(  # type: ignore
        cls: Type["IMorphoBlueHyperdriveUnsafeCastToUint112ContractError"],
        data: HexBytes,
    ) -> tuple[Any, ...]:
        """Decodes error data returns from a smart contract."""
        error_abi = cast(
            ABIFunction,
            [
                item
                for item in imorphobluehyperdrive_abi
                if item.get("name") == "UnsafeCastToUint112" and item.get("type") == "error"
            ][0],
        )
        types = get_abi_input_types(error_abi)
        abi_codec = ABICodec(default_registry)
        decoded = abi_codec.decode(types, data)
        return decoded


class IMorphoBlueHyperdriveUnsafeCastToUint128ContractError:
    """ContractError for UnsafeCastToUint128."""

    # @combomethod destroys return types, so we are redefining functions as both class and instance
    # pylint: disable=function-redefined

    # 4 byte error selector
    selector: str
    # error signature, i.e. CustomError(uint256,bool)
    signature: str

    # pylint: disable=useless-parent-delegation
    def __init__(
        self: "IMorphoBlueHyperdriveUnsafeCastToUint128ContractError",
    ) -> None:
        self.selector = "0x1e15f2a2"
        self.signature = "UnsafeCastToUint128()"

    def decode_error_data(  # type: ignore
        self: "IMorphoBlueHyperdriveUnsafeCastToUint128ContractError",
        data: HexBytes,
        # TODO: instead of returning a tuple, return a dataclass with the input names and types just like we do for functions
    ) -> tuple[Any, ...]:
        """Decodes error data returns from a smart contract."""
        error_abi = cast(
            ABIFunction,
            [
                item
                for item in imorphobluehyperdrive_abi
                if item.get("name") == "UnsafeCastToUint128" and item.get("type") == "error"
            ][0],
        )
        types = get_abi_input_types(error_abi)
        abi_codec = ABICodec(default_registry)
        decoded = abi_codec.decode(types, data)
        return decoded

    @classmethod
    def decode_error_data(  # type: ignore
        cls: Type["IMorphoBlueHyperdriveUnsafeCastToUint128ContractError"],
        data: HexBytes,
    ) -> tuple[Any, ...]:
        """Decodes error data returns from a smart contract."""
        error_abi = cast(
            ABIFunction,
            [
                item
                for item in imorphobluehyperdrive_abi
                if item.get("name") == "UnsafeCastToUint128" and item.get("type") == "error"
            ][0],
        )
        types = get_abi_input_types(error_abi)
        abi_codec = ABICodec(default_registry)
        decoded = abi_codec.decode(types, data)
        return decoded


class IMorphoBlueHyperdriveUnsupportedTokenContractError:
    """ContractError for UnsupportedToken."""

    # @combomethod destroys return types, so we are redefining functions as both class and instance
    # pylint: disable=function-redefined

    # 4 byte error selector
    selector: str
    # error signature, i.e. CustomError(uint256,bool)
    signature: str

    # pylint: disable=useless-parent-delegation
    def __init__(
        self: "IMorphoBlueHyperdriveUnsupportedTokenContractError",
    ) -> None:
        self.selector = "0x6a172882"
        self.signature = "UnsupportedToken()"

    def decode_error_data(  # type: ignore
        self: "IMorphoBlueHyperdriveUnsupportedTokenContractError",
        data: HexBytes,
        # TODO: instead of returning a tuple, return a dataclass with the input names and types just like we do for functions
    ) -> tuple[Any, ...]:
        """Decodes error data returns from a smart contract."""
        error_abi = cast(
            ABIFunction,
            [
                item
                for item in imorphobluehyperdrive_abi
                if item.get("name") == "UnsupportedToken" and item.get("type") == "error"
            ][0],
        )
        types = get_abi_input_types(error_abi)
        abi_codec = ABICodec(default_registry)
        decoded = abi_codec.decode(types, data)
        return decoded

    @classmethod
    def decode_error_data(  # type: ignore
        cls: Type["IMorphoBlueHyperdriveUnsupportedTokenContractError"],
        data: HexBytes,
    ) -> tuple[Any, ...]:
        """Decodes error data returns from a smart contract."""
        error_abi = cast(
            ABIFunction,
            [
                item
                for item in imorphobluehyperdrive_abi
                if item.get("name") == "UnsupportedToken" and item.get("type") == "error"
            ][0],
        )
        types = get_abi_input_types(error_abi)
        abi_codec = ABICodec(default_registry)
        decoded = abi_codec.decode(types, data)
        return decoded


class IMorphoBlueHyperdriveUpdateLiquidityFailedContractError:
    """ContractError for UpdateLiquidityFailed."""

    # @combomethod destroys return types, so we are redefining functions as both class and instance
    # pylint: disable=function-redefined

    # 4 byte error selector
    selector: str
    # error signature, i.e. CustomError(uint256,bool)
    signature: str

    # pylint: disable=useless-parent-delegation
    def __init__(
        self: "IMorphoBlueHyperdriveUpdateLiquidityFailedContractError",
    ) -> None:
        self.selector = "0x5044b7f5"
        self.signature = "UpdateLiquidityFailed()"

    def decode_error_data(  # type: ignore
        self: "IMorphoBlueHyperdriveUpdateLiquidityFailedContractError",
        data: HexBytes,
        # TODO: instead of returning a tuple, return a dataclass with the input names and types just like we do for functions
    ) -> tuple[Any, ...]:
        """Decodes error data returns from a smart contract."""
        error_abi = cast(
            ABIFunction,
            [
                item
                for item in imorphobluehyperdrive_abi
                if item.get("name") == "UpdateLiquidityFailed" and item.get("type") == "error"
            ][0],
        )
        types = get_abi_input_types(error_abi)
        abi_codec = ABICodec(default_registry)
        decoded = abi_codec.decode(types, data)
        return decoded

    @classmethod
    def decode_error_data(  # type: ignore
        cls: Type["IMorphoBlueHyperdriveUpdateLiquidityFailedContractError"],
        data: HexBytes,
    ) -> tuple[Any, ...]:
        """Decodes error data returns from a smart contract."""
        error_abi = cast(
            ABIFunction,
            [
                item
                for item in imorphobluehyperdrive_abi
                if item.get("name") == "UpdateLiquidityFailed" and item.get("type") == "error"
            ][0],
        )
        types = get_abi_input_types(error_abi)
        abi_codec = ABICodec(default_registry)
        decoded = abi_codec.decode(types, data)
        return decoded


class IMorphoBlueHyperdriveContractErrors:
    """ContractErrors for the IMorphoBlueHyperdrive contract."""

    BatchInputLengthMismatch: IMorphoBlueHyperdriveBatchInputLengthMismatchContractError

    BelowMinimumContribution: IMorphoBlueHyperdriveBelowMinimumContributionContractError

    CircuitBreakerTriggered: IMorphoBlueHyperdriveCircuitBreakerTriggeredContractError

    DecreasedPresentValueWhenAddingLiquidity: IMorphoBlueHyperdriveDecreasedPresentValueWhenAddingLiquidityContractError

    DistributeExcessIdleFailed: IMorphoBlueHyperdriveDistributeExcessIdleFailedContractError

    ExpInvalidExponent: IMorphoBlueHyperdriveExpInvalidExponentContractError

    ExpiredDeadline: IMorphoBlueHyperdriveExpiredDeadlineContractError

    InsufficientBalance: IMorphoBlueHyperdriveInsufficientBalanceContractError

    InsufficientLiquidity: IMorphoBlueHyperdriveInsufficientLiquidityContractError

    InvalidApr: IMorphoBlueHyperdriveInvalidAprContractError

    InvalidCheckpointTime: IMorphoBlueHyperdriveInvalidCheckpointTimeContractError

    InvalidERC20Bridge: IMorphoBlueHyperdriveInvalidERC20BridgeContractError

    InvalidEffectiveShareReserves: IMorphoBlueHyperdriveInvalidEffectiveShareReservesContractError

    InvalidFeeDestination: IMorphoBlueHyperdriveInvalidFeeDestinationContractError

    InvalidInitialVaultSharePrice: IMorphoBlueHyperdriveInvalidInitialVaultSharePriceContractError

    InvalidLPSharePrice: IMorphoBlueHyperdriveInvalidLPSharePriceContractError

    InvalidPresentValue: IMorphoBlueHyperdriveInvalidPresentValueContractError

    InvalidSignature: IMorphoBlueHyperdriveInvalidSignatureContractError

    InvalidTimestamp: IMorphoBlueHyperdriveInvalidTimestampContractError

    LnInvalidInput: IMorphoBlueHyperdriveLnInvalidInputContractError

    MinimumSharePrice: IMorphoBlueHyperdriveMinimumSharePriceContractError

    MinimumTransactionAmount: IMorphoBlueHyperdriveMinimumTransactionAmountContractError

    NotPayable: IMorphoBlueHyperdriveNotPayableContractError

    OutputLimit: IMorphoBlueHyperdriveOutputLimitContractError

    PoolAlreadyInitialized: IMorphoBlueHyperdrivePoolAlreadyInitializedContractError

    PoolIsPaused: IMorphoBlueHyperdrivePoolIsPausedContractError

    RestrictedZeroAddress: IMorphoBlueHyperdriveRestrictedZeroAddressContractError

    ReturnData: IMorphoBlueHyperdriveReturnDataContractError

    SweepFailed: IMorphoBlueHyperdriveSweepFailedContractError

    TransferFailed: IMorphoBlueHyperdriveTransferFailedContractError

    Unauthorized: IMorphoBlueHyperdriveUnauthorizedContractError

    UnexpectedSuccess: IMorphoBlueHyperdriveUnexpectedSuccessContractError

    UnsafeCastToInt128: IMorphoBlueHyperdriveUnsafeCastToInt128ContractError

    UnsafeCastToInt256: IMorphoBlueHyperdriveUnsafeCastToInt256ContractError

    UnsafeCastToUint112: IMorphoBlueHyperdriveUnsafeCastToUint112ContractError

    UnsafeCastToUint128: IMorphoBlueHyperdriveUnsafeCastToUint128ContractError

    UnsupportedToken: IMorphoBlueHyperdriveUnsupportedTokenContractError

    UpdateLiquidityFailed: IMorphoBlueHyperdriveUpdateLiquidityFailedContractError

    def __init__(
        self,
    ) -> None:
        self.BatchInputLengthMismatch = IMorphoBlueHyperdriveBatchInputLengthMismatchContractError()
        self.BelowMinimumContribution = IMorphoBlueHyperdriveBelowMinimumContributionContractError()
        self.CircuitBreakerTriggered = IMorphoBlueHyperdriveCircuitBreakerTriggeredContractError()
        self.DecreasedPresentValueWhenAddingLiquidity = (
            IMorphoBlueHyperdriveDecreasedPresentValueWhenAddingLiquidityContractError()
        )
        self.DistributeExcessIdleFailed = IMorphoBlueHyperdriveDistributeExcessIdleFailedContractError()
        self.ExpInvalidExponent = IMorphoBlueHyperdriveExpInvalidExponentContractError()
        self.ExpiredDeadline = IMorphoBlueHyperdriveExpiredDeadlineContractError()
        self.InsufficientBalance = IMorphoBlueHyperdriveInsufficientBalanceContractError()
        self.InsufficientLiquidity = IMorphoBlueHyperdriveInsufficientLiquidityContractError()
        self.InvalidApr = IMorphoBlueHyperdriveInvalidAprContractError()
        self.InvalidCheckpointTime = IMorphoBlueHyperdriveInvalidCheckpointTimeContractError()
        self.InvalidERC20Bridge = IMorphoBlueHyperdriveInvalidERC20BridgeContractError()
        self.InvalidEffectiveShareReserves = IMorphoBlueHyperdriveInvalidEffectiveShareReservesContractError()
        self.InvalidFeeDestination = IMorphoBlueHyperdriveInvalidFeeDestinationContractError()
        self.InvalidInitialVaultSharePrice = IMorphoBlueHyperdriveInvalidInitialVaultSharePriceContractError()
        self.InvalidLPSharePrice = IMorphoBlueHyperdriveInvalidLPSharePriceContractError()
        self.InvalidPresentValue = IMorphoBlueHyperdriveInvalidPresentValueContractError()
        self.InvalidSignature = IMorphoBlueHyperdriveInvalidSignatureContractError()
        self.InvalidTimestamp = IMorphoBlueHyperdriveInvalidTimestampContractError()
        self.LnInvalidInput = IMorphoBlueHyperdriveLnInvalidInputContractError()
        self.MinimumSharePrice = IMorphoBlueHyperdriveMinimumSharePriceContractError()
        self.MinimumTransactionAmount = IMorphoBlueHyperdriveMinimumTransactionAmountContractError()
        self.NotPayable = IMorphoBlueHyperdriveNotPayableContractError()
        self.OutputLimit = IMorphoBlueHyperdriveOutputLimitContractError()
        self.PoolAlreadyInitialized = IMorphoBlueHyperdrivePoolAlreadyInitializedContractError()
        self.PoolIsPaused = IMorphoBlueHyperdrivePoolIsPausedContractError()
        self.RestrictedZeroAddress = IMorphoBlueHyperdriveRestrictedZeroAddressContractError()
        self.ReturnData = IMorphoBlueHyperdriveReturnDataContractError()
        self.SweepFailed = IMorphoBlueHyperdriveSweepFailedContractError()
        self.TransferFailed = IMorphoBlueHyperdriveTransferFailedContractError()
        self.Unauthorized = IMorphoBlueHyperdriveUnauthorizedContractError()
        self.UnexpectedSuccess = IMorphoBlueHyperdriveUnexpectedSuccessContractError()
        self.UnsafeCastToInt128 = IMorphoBlueHyperdriveUnsafeCastToInt128ContractError()
        self.UnsafeCastToInt256 = IMorphoBlueHyperdriveUnsafeCastToInt256ContractError()
        self.UnsafeCastToUint112 = IMorphoBlueHyperdriveUnsafeCastToUint112ContractError()
        self.UnsafeCastToUint128 = IMorphoBlueHyperdriveUnsafeCastToUint128ContractError()
        self.UnsupportedToken = IMorphoBlueHyperdriveUnsupportedTokenContractError()
        self.UpdateLiquidityFailed = IMorphoBlueHyperdriveUpdateLiquidityFailedContractError()

        self._all = [
            self.BatchInputLengthMismatch,
            self.BelowMinimumContribution,
            self.CircuitBreakerTriggered,
            self.DecreasedPresentValueWhenAddingLiquidity,
            self.DistributeExcessIdleFailed,
            self.ExpInvalidExponent,
            self.ExpiredDeadline,
            self.InsufficientBalance,
            self.InsufficientLiquidity,
            self.InvalidApr,
            self.InvalidCheckpointTime,
            self.InvalidERC20Bridge,
            self.InvalidEffectiveShareReserves,
            self.InvalidFeeDestination,
            self.InvalidInitialVaultSharePrice,
            self.InvalidLPSharePrice,
            self.InvalidPresentValue,
            self.InvalidSignature,
            self.InvalidTimestamp,
            self.LnInvalidInput,
            self.MinimumSharePrice,
            self.MinimumTransactionAmount,
            self.NotPayable,
            self.OutputLimit,
            self.PoolAlreadyInitialized,
            self.PoolIsPaused,
            self.RestrictedZeroAddress,
            self.ReturnData,
            self.SweepFailed,
            self.TransferFailed,
            self.Unauthorized,
            self.UnexpectedSuccess,
            self.UnsafeCastToInt128,
            self.UnsafeCastToInt256,
            self.UnsafeCastToUint112,
            self.UnsafeCastToUint128,
            self.UnsupportedToken,
            self.UpdateLiquidityFailed,
        ]

    def decode_custom_error(self, data: str) -> tuple[Any, ...]:
        """Decodes a custom contract error."""
        selector = data[:10]
        for err in self._all:
            if err.selector == selector:
                return err.decode_error_data(HexBytes(data[10:]))

        raise ValueError(f"IMorphoBlueHyperdrive does not have a selector matching {selector}")


imorphobluehyperdrive_abi: ABI = cast(
    ABI,
    [
        {
            "type": "function",
            "name": "PERMIT_TYPEHASH",
            "inputs": [],
            "outputs": [{"name": "", "type": "bytes32", "internalType": "bytes32"}],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "addLiquidity",
            "inputs": [
                {"name": "_contribution", "type": "uint256", "internalType": "uint256"},
                {"name": "_minLpSharePrice", "type": "uint256", "internalType": "uint256"},
                {"name": "_minApr", "type": "uint256", "internalType": "uint256"},
                {"name": "_maxApr", "type": "uint256", "internalType": "uint256"},
                {
                    "name": "_options",
                    "type": "tuple",
                    "internalType": "struct IHyperdrive.Options",
                    "components": [
                        {"name": "destination", "type": "address", "internalType": "address"},
                        {"name": "asBase", "type": "bool", "internalType": "bool"},
                        {"name": "extraData", "type": "bytes", "internalType": "bytes"},
                    ],
                },
            ],
            "outputs": [{"name": "lpShares", "type": "uint256", "internalType": "uint256"}],
            "stateMutability": "payable",
        },
        {
            "type": "function",
            "name": "balanceOf",
            "inputs": [
                {"name": "tokenId", "type": "uint256", "internalType": "uint256"},
                {"name": "owner", "type": "address", "internalType": "address"},
            ],
            "outputs": [{"name": "", "type": "uint256", "internalType": "uint256"}],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "baseToken",
            "inputs": [],
            "outputs": [{"name": "", "type": "address", "internalType": "address"}],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "batchTransferFrom",
            "inputs": [
                {"name": "from", "type": "address", "internalType": "address"},
                {"name": "to", "type": "address", "internalType": "address"},
                {"name": "ids", "type": "uint256[]", "internalType": "uint256[]"},
                {"name": "values", "type": "uint256[]", "internalType": "uint256[]"},
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "checkpoint",
            "inputs": [
                {"name": "_checkpointTime", "type": "uint256", "internalType": "uint256"},
                {"name": "_maxIterations", "type": "uint256", "internalType": "uint256"},
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "closeLong",
            "inputs": [
                {"name": "_maturityTime", "type": "uint256", "internalType": "uint256"},
                {"name": "_bondAmount", "type": "uint256", "internalType": "uint256"},
                {"name": "_minOutput", "type": "uint256", "internalType": "uint256"},
                {
                    "name": "_options",
                    "type": "tuple",
                    "internalType": "struct IHyperdrive.Options",
                    "components": [
                        {"name": "destination", "type": "address", "internalType": "address"},
                        {"name": "asBase", "type": "bool", "internalType": "bool"},
                        {"name": "extraData", "type": "bytes", "internalType": "bytes"},
                    ],
                },
            ],
            "outputs": [{"name": "proceeds", "type": "uint256", "internalType": "uint256"}],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "closeShort",
            "inputs": [
                {"name": "_maturityTime", "type": "uint256", "internalType": "uint256"},
                {"name": "_bondAmount", "type": "uint256", "internalType": "uint256"},
                {"name": "_minOutput", "type": "uint256", "internalType": "uint256"},
                {
                    "name": "_options",
                    "type": "tuple",
                    "internalType": "struct IHyperdrive.Options",
                    "components": [
                        {"name": "destination", "type": "address", "internalType": "address"},
                        {"name": "asBase", "type": "bool", "internalType": "bool"},
                        {"name": "extraData", "type": "bytes", "internalType": "bytes"},
                    ],
                },
            ],
            "outputs": [{"name": "proceeds", "type": "uint256", "internalType": "uint256"}],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "collateralToken",
            "inputs": [],
            "outputs": [{"name": "", "type": "address", "internalType": "address"}],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "collectGovernanceFee",
            "inputs": [
                {
                    "name": "_options",
                    "type": "tuple",
                    "internalType": "struct IHyperdrive.Options",
                    "components": [
                        {"name": "destination", "type": "address", "internalType": "address"},
                        {"name": "asBase", "type": "bool", "internalType": "bool"},
                        {"name": "extraData", "type": "bytes", "internalType": "bytes"},
                    ],
                }
            ],
            "outputs": [{"name": "proceeds", "type": "uint256", "internalType": "uint256"}],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "convertToBase",
            "inputs": [{"name": "_shareAmount", "type": "uint256", "internalType": "uint256"}],
            "outputs": [{"name": "", "type": "uint256", "internalType": "uint256"}],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "convertToShares",
            "inputs": [{"name": "_baseAmount", "type": "uint256", "internalType": "uint256"}],
            "outputs": [{"name": "", "type": "uint256", "internalType": "uint256"}],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "decimals",
            "inputs": [],
            "outputs": [{"name": "", "type": "uint8", "internalType": "uint8"}],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "domainSeparator",
            "inputs": [],
            "outputs": [{"name": "", "type": "bytes32", "internalType": "bytes32"}],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "getCheckpoint",
            "inputs": [{"name": "_checkpointTime", "type": "uint256", "internalType": "uint256"}],
            "outputs": [
                {
                    "name": "",
                    "type": "tuple",
                    "internalType": "struct IHyperdrive.Checkpoint",
                    "components": [
                        {"name": "weightedSpotPrice", "type": "uint128", "internalType": "uint128"},
                        {"name": "lastWeightedSpotPriceUpdateTime", "type": "uint128", "internalType": "uint128"},
                        {"name": "vaultSharePrice", "type": "uint128", "internalType": "uint128"},
                    ],
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "getCheckpointExposure",
            "inputs": [{"name": "_checkpointTime", "type": "uint256", "internalType": "uint256"}],
            "outputs": [{"name": "", "type": "int256", "internalType": "int256"}],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "getMarketState",
            "inputs": [],
            "outputs": [
                {
                    "name": "",
                    "type": "tuple",
                    "internalType": "struct IHyperdrive.MarketState",
                    "components": [
                        {"name": "shareReserves", "type": "uint128", "internalType": "uint128"},
                        {"name": "bondReserves", "type": "uint128", "internalType": "uint128"},
                        {"name": "longExposure", "type": "uint128", "internalType": "uint128"},
                        {"name": "longsOutstanding", "type": "uint128", "internalType": "uint128"},
                        {"name": "shareAdjustment", "type": "int128", "internalType": "int128"},
                        {"name": "shortsOutstanding", "type": "uint128", "internalType": "uint128"},
                        {"name": "longAverageMaturityTime", "type": "uint128", "internalType": "uint128"},
                        {"name": "shortAverageMaturityTime", "type": "uint128", "internalType": "uint128"},
                        {"name": "isInitialized", "type": "bool", "internalType": "bool"},
                        {"name": "isPaused", "type": "bool", "internalType": "bool"},
                        {"name": "zombieBaseProceeds", "type": "uint112", "internalType": "uint112"},
                        {"name": "zombieShareReserves", "type": "uint128", "internalType": "uint128"},
                    ],
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "getPoolConfig",
            "inputs": [],
            "outputs": [
                {
                    "name": "",
                    "type": "tuple",
                    "internalType": "struct IHyperdrive.PoolConfig",
                    "components": [
                        {"name": "baseToken", "type": "address", "internalType": "contract IERC20"},
                        {"name": "vaultSharesToken", "type": "address", "internalType": "contract IERC20"},
                        {"name": "linkerFactory", "type": "address", "internalType": "address"},
                        {"name": "linkerCodeHash", "type": "bytes32", "internalType": "bytes32"},
                        {"name": "initialVaultSharePrice", "type": "uint256", "internalType": "uint256"},
                        {"name": "minimumShareReserves", "type": "uint256", "internalType": "uint256"},
                        {"name": "minimumTransactionAmount", "type": "uint256", "internalType": "uint256"},
                        {"name": "circuitBreakerDelta", "type": "uint256", "internalType": "uint256"},
                        {"name": "positionDuration", "type": "uint256", "internalType": "uint256"},
                        {"name": "checkpointDuration", "type": "uint256", "internalType": "uint256"},
                        {"name": "timeStretch", "type": "uint256", "internalType": "uint256"},
                        {"name": "governance", "type": "address", "internalType": "address"},
                        {"name": "feeCollector", "type": "address", "internalType": "address"},
                        {"name": "sweepCollector", "type": "address", "internalType": "address"},
                        {"name": "checkpointRewarder", "type": "address", "internalType": "address"},
                        {
                            "name": "fees",
                            "type": "tuple",
                            "internalType": "struct IHyperdrive.Fees",
                            "components": [
                                {"name": "curve", "type": "uint256", "internalType": "uint256"},
                                {"name": "flat", "type": "uint256", "internalType": "uint256"},
                                {"name": "governanceLP", "type": "uint256", "internalType": "uint256"},
                                {"name": "governanceZombie", "type": "uint256", "internalType": "uint256"},
                            ],
                        },
                    ],
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "getPoolInfo",
            "inputs": [],
            "outputs": [
                {
                    "name": "",
                    "type": "tuple",
                    "internalType": "struct IHyperdrive.PoolInfo",
                    "components": [
                        {"name": "shareReserves", "type": "uint256", "internalType": "uint256"},
                        {"name": "shareAdjustment", "type": "int256", "internalType": "int256"},
                        {"name": "zombieBaseProceeds", "type": "uint256", "internalType": "uint256"},
                        {"name": "zombieShareReserves", "type": "uint256", "internalType": "uint256"},
                        {"name": "bondReserves", "type": "uint256", "internalType": "uint256"},
                        {"name": "lpTotalSupply", "type": "uint256", "internalType": "uint256"},
                        {"name": "vaultSharePrice", "type": "uint256", "internalType": "uint256"},
                        {"name": "longsOutstanding", "type": "uint256", "internalType": "uint256"},
                        {"name": "longAverageMaturityTime", "type": "uint256", "internalType": "uint256"},
                        {"name": "shortsOutstanding", "type": "uint256", "internalType": "uint256"},
                        {"name": "shortAverageMaturityTime", "type": "uint256", "internalType": "uint256"},
                        {"name": "withdrawalSharesReadyToWithdraw", "type": "uint256", "internalType": "uint256"},
                        {"name": "withdrawalSharesProceeds", "type": "uint256", "internalType": "uint256"},
                        {"name": "lpSharePrice", "type": "uint256", "internalType": "uint256"},
                        {"name": "longExposure", "type": "uint256", "internalType": "uint256"},
                    ],
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "getUncollectedGovernanceFees",
            "inputs": [],
            "outputs": [{"name": "", "type": "uint256", "internalType": "uint256"}],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "getWithdrawPool",
            "inputs": [],
            "outputs": [
                {
                    "name": "",
                    "type": "tuple",
                    "internalType": "struct IHyperdrive.WithdrawPool",
                    "components": [
                        {"name": "readyToWithdraw", "type": "uint128", "internalType": "uint128"},
                        {"name": "proceeds", "type": "uint128", "internalType": "uint128"},
                    ],
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "initialize",
            "inputs": [
                {"name": "_contribution", "type": "uint256", "internalType": "uint256"},
                {"name": "_apr", "type": "uint256", "internalType": "uint256"},
                {
                    "name": "_options",
                    "type": "tuple",
                    "internalType": "struct IHyperdrive.Options",
                    "components": [
                        {"name": "destination", "type": "address", "internalType": "address"},
                        {"name": "asBase", "type": "bool", "internalType": "bool"},
                        {"name": "extraData", "type": "bytes", "internalType": "bytes"},
                    ],
                },
            ],
            "outputs": [{"name": "lpShares", "type": "uint256", "internalType": "uint256"}],
            "stateMutability": "payable",
        },
        {
            "type": "function",
            "name": "irm",
            "inputs": [],
            "outputs": [{"name": "", "type": "address", "internalType": "address"}],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "isApprovedForAll",
            "inputs": [
                {"name": "owner", "type": "address", "internalType": "address"},
                {"name": "spender", "type": "address", "internalType": "address"},
            ],
            "outputs": [{"name": "", "type": "bool", "internalType": "bool"}],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "isPauser",
            "inputs": [{"name": "_account", "type": "address", "internalType": "address"}],
            "outputs": [{"name": "", "type": "bool", "internalType": "bool"}],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "kind",
            "inputs": [],
            "outputs": [{"name": "", "type": "string", "internalType": "string"}],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "lltv",
            "inputs": [],
            "outputs": [{"name": "", "type": "uint256", "internalType": "uint256"}],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "load",
            "inputs": [{"name": "_slots", "type": "uint256[]", "internalType": "uint256[]"}],
            "outputs": [{"name": "", "type": "bytes32[]", "internalType": "bytes32[]"}],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "name",
            "inputs": [{"name": "tokenId", "type": "uint256", "internalType": "uint256"}],
            "outputs": [{"name": "", "type": "string", "internalType": "string"}],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "name",
            "inputs": [],
            "outputs": [{"name": "", "type": "string", "internalType": "string"}],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "nonces",
            "inputs": [{"name": "owner", "type": "address", "internalType": "address"}],
            "outputs": [{"name": "", "type": "uint256", "internalType": "uint256"}],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "openLong",
            "inputs": [
                {"name": "_amount", "type": "uint256", "internalType": "uint256"},
                {"name": "_minOutput", "type": "uint256", "internalType": "uint256"},
                {"name": "_minVaultSharePrice", "type": "uint256", "internalType": "uint256"},
                {
                    "name": "_options",
                    "type": "tuple",
                    "internalType": "struct IHyperdrive.Options",
                    "components": [
                        {"name": "destination", "type": "address", "internalType": "address"},
                        {"name": "asBase", "type": "bool", "internalType": "bool"},
                        {"name": "extraData", "type": "bytes", "internalType": "bytes"},
                    ],
                },
            ],
            "outputs": [
                {"name": "maturityTime", "type": "uint256", "internalType": "uint256"},
                {"name": "bondProceeds", "type": "uint256", "internalType": "uint256"},
            ],
            "stateMutability": "payable",
        },
        {
            "type": "function",
            "name": "openShort",
            "inputs": [
                {"name": "_bondAmount", "type": "uint256", "internalType": "uint256"},
                {"name": "_maxDeposit", "type": "uint256", "internalType": "uint256"},
                {"name": "_minVaultSharePrice", "type": "uint256", "internalType": "uint256"},
                {
                    "name": "_options",
                    "type": "tuple",
                    "internalType": "struct IHyperdrive.Options",
                    "components": [
                        {"name": "destination", "type": "address", "internalType": "address"},
                        {"name": "asBase", "type": "bool", "internalType": "bool"},
                        {"name": "extraData", "type": "bytes", "internalType": "bytes"},
                    ],
                },
            ],
            "outputs": [
                {"name": "maturityTime", "type": "uint256", "internalType": "uint256"},
                {"name": "deposit", "type": "uint256", "internalType": "uint256"},
            ],
            "stateMutability": "payable",
        },
        {
            "type": "function",
            "name": "oracle",
            "inputs": [],
            "outputs": [{"name": "", "type": "address", "internalType": "address"}],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "pause",
            "inputs": [{"name": "_status", "type": "bool", "internalType": "bool"}],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "perTokenApprovals",
            "inputs": [
                {"name": "tokenId", "type": "uint256", "internalType": "uint256"},
                {"name": "owner", "type": "address", "internalType": "address"},
                {"name": "spender", "type": "address", "internalType": "address"},
            ],
            "outputs": [{"name": "", "type": "uint256", "internalType": "uint256"}],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "permitForAll",
            "inputs": [
                {"name": "owner", "type": "address", "internalType": "address"},
                {"name": "spender", "type": "address", "internalType": "address"},
                {"name": "_approved", "type": "bool", "internalType": "bool"},
                {"name": "deadline", "type": "uint256", "internalType": "uint256"},
                {"name": "v", "type": "uint8", "internalType": "uint8"},
                {"name": "r", "type": "bytes32", "internalType": "bytes32"},
                {"name": "s", "type": "bytes32", "internalType": "bytes32"},
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "redeemWithdrawalShares",
            "inputs": [
                {"name": "_withdrawalShares", "type": "uint256", "internalType": "uint256"},
                {"name": "_minOutputPerShare", "type": "uint256", "internalType": "uint256"},
                {
                    "name": "_options",
                    "type": "tuple",
                    "internalType": "struct IHyperdrive.Options",
                    "components": [
                        {"name": "destination", "type": "address", "internalType": "address"},
                        {"name": "asBase", "type": "bool", "internalType": "bool"},
                        {"name": "extraData", "type": "bytes", "internalType": "bytes"},
                    ],
                },
            ],
            "outputs": [
                {"name": "proceeds", "type": "uint256", "internalType": "uint256"},
                {"name": "withdrawalSharesRedeemed", "type": "uint256", "internalType": "uint256"},
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "removeLiquidity",
            "inputs": [
                {"name": "_lpShares", "type": "uint256", "internalType": "uint256"},
                {"name": "_minOutputPerShare", "type": "uint256", "internalType": "uint256"},
                {
                    "name": "_options",
                    "type": "tuple",
                    "internalType": "struct IHyperdrive.Options",
                    "components": [
                        {"name": "destination", "type": "address", "internalType": "address"},
                        {"name": "asBase", "type": "bool", "internalType": "bool"},
                        {"name": "extraData", "type": "bytes", "internalType": "bytes"},
                    ],
                },
            ],
            "outputs": [
                {"name": "proceeds", "type": "uint256", "internalType": "uint256"},
                {"name": "withdrawalShares", "type": "uint256", "internalType": "uint256"},
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "setApproval",
            "inputs": [
                {"name": "tokenID", "type": "uint256", "internalType": "uint256"},
                {"name": "operator", "type": "address", "internalType": "address"},
                {"name": "amount", "type": "uint256", "internalType": "uint256"},
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "setApprovalBridge",
            "inputs": [
                {"name": "tokenID", "type": "uint256", "internalType": "uint256"},
                {"name": "operator", "type": "address", "internalType": "address"},
                {"name": "amount", "type": "uint256", "internalType": "uint256"},
                {"name": "caller", "type": "address", "internalType": "address"},
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "setApprovalForAll",
            "inputs": [
                {"name": "operator", "type": "address", "internalType": "address"},
                {"name": "approved", "type": "bool", "internalType": "bool"},
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "setCheckpointRewarder",
            "inputs": [{"name": "_checkpointRewarder", "type": "address", "internalType": "address"}],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "setFeeCollector",
            "inputs": [{"name": "_who", "type": "address", "internalType": "address"}],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "setGovernance",
            "inputs": [{"name": "_who", "type": "address", "internalType": "address"}],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "setPauser",
            "inputs": [
                {"name": "who", "type": "address", "internalType": "address"},
                {"name": "status", "type": "bool", "internalType": "bool"},
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "setSweepCollector",
            "inputs": [{"name": "_who", "type": "address", "internalType": "address"}],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "sweep",
            "inputs": [{"name": "_target", "type": "address", "internalType": "contract IERC20"}],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "symbol",
            "inputs": [{"name": "tokenId", "type": "uint256", "internalType": "uint256"}],
            "outputs": [{"name": "", "type": "string", "internalType": "string"}],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "target0",
            "inputs": [],
            "outputs": [{"name": "", "type": "address", "internalType": "address"}],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "target1",
            "inputs": [],
            "outputs": [{"name": "", "type": "address", "internalType": "address"}],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "target2",
            "inputs": [],
            "outputs": [{"name": "", "type": "address", "internalType": "address"}],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "target3",
            "inputs": [],
            "outputs": [{"name": "", "type": "address", "internalType": "address"}],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "target4",
            "inputs": [],
            "outputs": [{"name": "", "type": "address", "internalType": "address"}],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "totalSupply",
            "inputs": [{"name": "tokenId", "type": "uint256", "internalType": "uint256"}],
            "outputs": [{"name": "", "type": "uint256", "internalType": "uint256"}],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "transferFrom",
            "inputs": [
                {"name": "tokenID", "type": "uint256", "internalType": "uint256"},
                {"name": "from", "type": "address", "internalType": "address"},
                {"name": "to", "type": "address", "internalType": "address"},
                {"name": "amount", "type": "uint256", "internalType": "uint256"},
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "transferFromBridge",
            "inputs": [
                {"name": "tokenID", "type": "uint256", "internalType": "uint256"},
                {"name": "from", "type": "address", "internalType": "address"},
                {"name": "to", "type": "address", "internalType": "address"},
                {"name": "amount", "type": "uint256", "internalType": "uint256"},
                {"name": "caller", "type": "address", "internalType": "address"},
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "vault",
            "inputs": [],
            "outputs": [{"name": "", "type": "address", "internalType": "address"}],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "vaultSharesToken",
            "inputs": [],
            "outputs": [{"name": "", "type": "address", "internalType": "address"}],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "version",
            "inputs": [],
            "outputs": [{"name": "", "type": "string", "internalType": "string"}],
            "stateMutability": "pure",
        },
        {
            "type": "event",
            "name": "AddLiquidity",
            "inputs": [
                {"name": "provider", "type": "address", "indexed": True, "internalType": "address"},
                {"name": "lpAmount", "type": "uint256", "indexed": False, "internalType": "uint256"},
                {"name": "amount", "type": "uint256", "indexed": False, "internalType": "uint256"},
                {"name": "vaultSharePrice", "type": "uint256", "indexed": False, "internalType": "uint256"},
                {"name": "asBase", "type": "bool", "indexed": False, "internalType": "bool"},
                {"name": "lpSharePrice", "type": "uint256", "indexed": False, "internalType": "uint256"},
                {"name": "extraData", "type": "bytes", "indexed": False, "internalType": "bytes"},
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "Approval",
            "inputs": [
                {"name": "owner", "type": "address", "indexed": True, "internalType": "address"},
                {"name": "spender", "type": "address", "indexed": True, "internalType": "address"},
                {"name": "value", "type": "uint256", "indexed": False, "internalType": "uint256"},
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "ApprovalForAll",
            "inputs": [
                {"name": "account", "type": "address", "indexed": True, "internalType": "address"},
                {"name": "operator", "type": "address", "indexed": True, "internalType": "address"},
                {"name": "approved", "type": "bool", "indexed": False, "internalType": "bool"},
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "CheckpointRewarderUpdated",
            "inputs": [
                {"name": "newCheckpointRewarder", "type": "address", "indexed": True, "internalType": "address"}
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "CloseLong",
            "inputs": [
                {"name": "trader", "type": "address", "indexed": True, "internalType": "address"},
                {"name": "destination", "type": "address", "indexed": True, "internalType": "address"},
                {"name": "assetId", "type": "uint256", "indexed": True, "internalType": "uint256"},
                {"name": "maturityTime", "type": "uint256", "indexed": False, "internalType": "uint256"},
                {"name": "amount", "type": "uint256", "indexed": False, "internalType": "uint256"},
                {"name": "vaultSharePrice", "type": "uint256", "indexed": False, "internalType": "uint256"},
                {"name": "asBase", "type": "bool", "indexed": False, "internalType": "bool"},
                {"name": "bondAmount", "type": "uint256", "indexed": False, "internalType": "uint256"},
                {"name": "extraData", "type": "bytes", "indexed": False, "internalType": "bytes"},
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "CloseShort",
            "inputs": [
                {"name": "trader", "type": "address", "indexed": True, "internalType": "address"},
                {"name": "destination", "type": "address", "indexed": True, "internalType": "address"},
                {"name": "assetId", "type": "uint256", "indexed": True, "internalType": "uint256"},
                {"name": "maturityTime", "type": "uint256", "indexed": False, "internalType": "uint256"},
                {"name": "amount", "type": "uint256", "indexed": False, "internalType": "uint256"},
                {"name": "vaultSharePrice", "type": "uint256", "indexed": False, "internalType": "uint256"},
                {"name": "asBase", "type": "bool", "indexed": False, "internalType": "bool"},
                {"name": "basePayment", "type": "uint256", "indexed": False, "internalType": "uint256"},
                {"name": "bondAmount", "type": "uint256", "indexed": False, "internalType": "uint256"},
                {"name": "extraData", "type": "bytes", "indexed": False, "internalType": "bytes"},
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "CollectGovernanceFee",
            "inputs": [
                {"name": "collector", "type": "address", "indexed": True, "internalType": "address"},
                {"name": "amount", "type": "uint256", "indexed": False, "internalType": "uint256"},
                {"name": "vaultSharePrice", "type": "uint256", "indexed": False, "internalType": "uint256"},
                {"name": "asBase", "type": "bool", "indexed": False, "internalType": "bool"},
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "CreateCheckpoint",
            "inputs": [
                {"name": "checkpointTime", "type": "uint256", "indexed": True, "internalType": "uint256"},
                {"name": "checkpointVaultSharePrice", "type": "uint256", "indexed": False, "internalType": "uint256"},
                {"name": "vaultSharePrice", "type": "uint256", "indexed": False, "internalType": "uint256"},
                {"name": "maturedShorts", "type": "uint256", "indexed": False, "internalType": "uint256"},
                {"name": "maturedLongs", "type": "uint256", "indexed": False, "internalType": "uint256"},
                {"name": "lpSharePrice", "type": "uint256", "indexed": False, "internalType": "uint256"},
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "FeeCollectorUpdated",
            "inputs": [{"name": "newFeeCollector", "type": "address", "indexed": True, "internalType": "address"}],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "GovernanceUpdated",
            "inputs": [{"name": "newGovernance", "type": "address", "indexed": True, "internalType": "address"}],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "Initialize",
            "inputs": [
                {"name": "provider", "type": "address", "indexed": True, "internalType": "address"},
                {"name": "lpAmount", "type": "uint256", "indexed": False, "internalType": "uint256"},
                {"name": "amount", "type": "uint256", "indexed": False, "internalType": "uint256"},
                {"name": "vaultSharePrice", "type": "uint256", "indexed": False, "internalType": "uint256"},
                {"name": "asBase", "type": "bool", "indexed": False, "internalType": "bool"},
                {"name": "apr", "type": "uint256", "indexed": False, "internalType": "uint256"},
                {"name": "extraData", "type": "bytes", "indexed": False, "internalType": "bytes"},
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "OpenLong",
            "inputs": [
                {"name": "trader", "type": "address", "indexed": True, "internalType": "address"},
                {"name": "assetId", "type": "uint256", "indexed": True, "internalType": "uint256"},
                {"name": "maturityTime", "type": "uint256", "indexed": False, "internalType": "uint256"},
                {"name": "amount", "type": "uint256", "indexed": False, "internalType": "uint256"},
                {"name": "vaultSharePrice", "type": "uint256", "indexed": False, "internalType": "uint256"},
                {"name": "asBase", "type": "bool", "indexed": False, "internalType": "bool"},
                {"name": "bondAmount", "type": "uint256", "indexed": False, "internalType": "uint256"},
                {"name": "extraData", "type": "bytes", "indexed": False, "internalType": "bytes"},
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "OpenShort",
            "inputs": [
                {"name": "trader", "type": "address", "indexed": True, "internalType": "address"},
                {"name": "assetId", "type": "uint256", "indexed": True, "internalType": "uint256"},
                {"name": "maturityTime", "type": "uint256", "indexed": False, "internalType": "uint256"},
                {"name": "amount", "type": "uint256", "indexed": False, "internalType": "uint256"},
                {"name": "vaultSharePrice", "type": "uint256", "indexed": False, "internalType": "uint256"},
                {"name": "asBase", "type": "bool", "indexed": False, "internalType": "bool"},
                {"name": "baseProceeds", "type": "uint256", "indexed": False, "internalType": "uint256"},
                {"name": "bondAmount", "type": "uint256", "indexed": False, "internalType": "uint256"},
                {"name": "extraData", "type": "bytes", "indexed": False, "internalType": "bytes"},
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "PauseStatusUpdated",
            "inputs": [{"name": "isPaused", "type": "bool", "indexed": False, "internalType": "bool"}],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "PauserUpdated",
            "inputs": [
                {"name": "newPauser", "type": "address", "indexed": True, "internalType": "address"},
                {"name": "status", "type": "bool", "indexed": False, "internalType": "bool"},
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "RedeemWithdrawalShares",
            "inputs": [
                {"name": "provider", "type": "address", "indexed": True, "internalType": "address"},
                {"name": "destination", "type": "address", "indexed": True, "internalType": "address"},
                {"name": "withdrawalShareAmount", "type": "uint256", "indexed": False, "internalType": "uint256"},
                {"name": "amount", "type": "uint256", "indexed": False, "internalType": "uint256"},
                {"name": "vaultSharePrice", "type": "uint256", "indexed": False, "internalType": "uint256"},
                {"name": "asBase", "type": "bool", "indexed": False, "internalType": "bool"},
                {"name": "extraData", "type": "bytes", "indexed": False, "internalType": "bytes"},
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "RemoveLiquidity",
            "inputs": [
                {"name": "provider", "type": "address", "indexed": True, "internalType": "address"},
                {"name": "destination", "type": "address", "indexed": True, "internalType": "address"},
                {"name": "lpAmount", "type": "uint256", "indexed": False, "internalType": "uint256"},
                {"name": "amount", "type": "uint256", "indexed": False, "internalType": "uint256"},
                {"name": "vaultSharePrice", "type": "uint256", "indexed": False, "internalType": "uint256"},
                {"name": "asBase", "type": "bool", "indexed": False, "internalType": "bool"},
                {"name": "withdrawalShareAmount", "type": "uint256", "indexed": False, "internalType": "uint256"},
                {"name": "lpSharePrice", "type": "uint256", "indexed": False, "internalType": "uint256"},
                {"name": "extraData", "type": "bytes", "indexed": False, "internalType": "bytes"},
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "Sweep",
            "inputs": [
                {"name": "collector", "type": "address", "indexed": True, "internalType": "address"},
                {"name": "target", "type": "address", "indexed": True, "internalType": "address"},
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "SweepCollectorUpdated",
            "inputs": [{"name": "newSweepCollector", "type": "address", "indexed": True, "internalType": "address"}],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "TransferSingle",
            "inputs": [
                {"name": "operator", "type": "address", "indexed": True, "internalType": "address"},
                {"name": "from", "type": "address", "indexed": True, "internalType": "address"},
                {"name": "to", "type": "address", "indexed": True, "internalType": "address"},
                {"name": "id", "type": "uint256", "indexed": False, "internalType": "uint256"},
                {"name": "value", "type": "uint256", "indexed": False, "internalType": "uint256"},
            ],
            "anonymous": False,
        },
        {"type": "error", "name": "BatchInputLengthMismatch", "inputs": []},
        {"type": "error", "name": "BelowMinimumContribution", "inputs": []},
        {"type": "error", "name": "CircuitBreakerTriggered", "inputs": []},
        {"type": "error", "name": "DecreasedPresentValueWhenAddingLiquidity", "inputs": []},
        {"type": "error", "name": "DistributeExcessIdleFailed", "inputs": []},
        {"type": "error", "name": "ExpInvalidExponent", "inputs": []},
        {"type": "error", "name": "ExpiredDeadline", "inputs": []},
        {"type": "error", "name": "InsufficientBalance", "inputs": []},
        {"type": "error", "name": "InsufficientLiquidity", "inputs": []},
        {"type": "error", "name": "InvalidApr", "inputs": []},
        {"type": "error", "name": "InvalidCheckpointTime", "inputs": []},
        {"type": "error", "name": "InvalidERC20Bridge", "inputs": []},
        {"type": "error", "name": "InvalidEffectiveShareReserves", "inputs": []},
        {"type": "error", "name": "InvalidFeeDestination", "inputs": []},
        {"type": "error", "name": "InvalidInitialVaultSharePrice", "inputs": []},
        {"type": "error", "name": "InvalidLPSharePrice", "inputs": []},
        {"type": "error", "name": "InvalidPresentValue", "inputs": []},
        {"type": "error", "name": "InvalidSignature", "inputs": []},
        {"type": "error", "name": "InvalidTimestamp", "inputs": []},
        {"type": "error", "name": "LnInvalidInput", "inputs": []},
        {"type": "error", "name": "MinimumSharePrice", "inputs": []},
        {"type": "error", "name": "MinimumTransactionAmount", "inputs": []},
        {"type": "error", "name": "NotPayable", "inputs": []},
        {"type": "error", "name": "OutputLimit", "inputs": []},
        {"type": "error", "name": "PoolAlreadyInitialized", "inputs": []},
        {"type": "error", "name": "PoolIsPaused", "inputs": []},
        {"type": "error", "name": "RestrictedZeroAddress", "inputs": []},
        {"type": "error", "name": "ReturnData", "inputs": [{"name": "data", "type": "bytes", "internalType": "bytes"}]},
        {"type": "error", "name": "SweepFailed", "inputs": []},
        {"type": "error", "name": "TransferFailed", "inputs": []},
        {"type": "error", "name": "Unauthorized", "inputs": []},
        {"type": "error", "name": "UnexpectedSuccess", "inputs": []},
        {"type": "error", "name": "UnsafeCastToInt128", "inputs": []},
        {"type": "error", "name": "UnsafeCastToInt256", "inputs": []},
        {"type": "error", "name": "UnsafeCastToUint112", "inputs": []},
        {"type": "error", "name": "UnsafeCastToUint128", "inputs": []},
        {"type": "error", "name": "UnsupportedToken", "inputs": []},
        {"type": "error", "name": "UpdateLiquidityFailed", "inputs": []},
    ],
)
# pylint: disable=line-too-long
imorphobluehyperdrive_bytecode = HexStr("0x")


class IMorphoBlueHyperdriveContract(Contract):
    """A web3.py Contract class for the IMorphoBlueHyperdrive contract."""

    abi: ABI = imorphobluehyperdrive_abi
    bytecode: bytes | None = try_bytecode_hexbytes(imorphobluehyperdrive_bytecode, "imorphobluehyperdrive")

    def __init__(self, address: ChecksumAddress | None = None) -> None:
        try:
            # Initialize parent Contract class
            super().__init__(address=address)
            self.functions = IMorphoBlueHyperdriveContractFunctions(imorphobluehyperdrive_abi, self.w3, address)  # type: ignore
            self.events = IMorphoBlueHyperdriveContractEvents(imorphobluehyperdrive_abi, self.w3, address)  # type: ignore
            self.errors = IMorphoBlueHyperdriveContractErrors()

        except FallbackNotFound:
            print("Fallback function not found. Continuing...")

    events: IMorphoBlueHyperdriveContractEvents

    errors: IMorphoBlueHyperdriveContractErrors = IMorphoBlueHyperdriveContractErrors()

    functions: IMorphoBlueHyperdriveContractFunctions

    @classmethod
    def constructor(cls) -> ContractConstructor:  # type: ignore
        """Creates a transaction with the contract's constructor function.

        Parameters
        ----------

        w3 : Web3
            A web3 instance.
        account : LocalAccount
            The account to use to deploy the contract.

        Returns
        -------
        Self
            A deployed instance of the contract.

        """

        return super().constructor()

    @classmethod
    def deploy(cls, w3: Web3, account: LocalAccount | ChecksumAddress) -> Self:
        """Deploys and instance of the contract.

        Parameters
        ----------
        w3 : Web3
            A web3 instance.
        account : LocalAccount
            The account to use to deploy the contract.

        Returns
        -------
        Self
            A deployed instance of the contract.
        """
        deployer = cls.factory(w3=w3)
        constructor_fn = deployer.constructor()

        # if an address is supplied, try to use a web3 default account
        if isinstance(account, str):
            tx_hash = constructor_fn.transact({"from": account})
            tx_receipt = w3.eth.wait_for_transaction_receipt(tx_hash)

            deployed_contract = deployer(address=tx_receipt.contractAddress)  # type: ignore
            return deployed_contract

        # otherwise use the account provided.
        deployment_tx = constructor_fn.build_transaction()
        current_nonce = w3.eth.get_transaction_count(account.address, "pending")
        deployment_tx.update({"nonce": current_nonce})

        # Sign the transaction with local account private key
        signed_tx = account.sign_transaction(deployment_tx)

        # Send the signed transaction and wait for receipt
        tx_hash = w3.eth.send_raw_transaction(signed_tx.raw_transaction)
        tx_receipt = w3.eth.wait_for_transaction_receipt(tx_hash)

        deployed_contract = deployer(address=tx_receipt.contractAddress)  # type: ignore
        return deployed_contract

    @classmethod
    def factory(cls, w3: Web3, class_name: str | None = None, **kwargs: Any) -> Type[Self]:
        """Deploys and instance of the contract.

        Parameters
        ----------
        w3 : Web3
            A web3 instance.
        class_name: str | None
            The instance class name.

        Returns
        -------
        Self
            A deployed instance of the contract.
        """
        contract = super().factory(w3, class_name, **kwargs)
        contract.functions = IMorphoBlueHyperdriveContractFunctions(imorphobluehyperdrive_abi, w3, None)
        contract.errors = IMorphoBlueHyperdriveContractErrors()

        return contract
