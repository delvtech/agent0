:py:mod:`elfpy.pricing_models.yieldspace`
=========================================

.. py:module:: elfpy.pricing_models.yieldspace

.. autoapi-nested-parse::

   The YieldSpace pricing model.

   ..
       !! processed by numpydoc !!


Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   elfpy.pricing_models.yieldspace.YieldSpacePricingModel




.. py:class:: YieldSpacePricingModel

   Bases: :py:obj:`elfpy.pricing_models.base.PricingModel`

   
   YieldSpace Pricing Model

   This pricing model uses the YieldSpace invariant with modifications to
   enable the base reserves to be deposited into yield bearing vaults















   ..
       !! processed by numpydoc !!
   .. py:method:: model_name() -> str

      
      Unique name given to the model, can be based on member variable states
















      ..
          !! processed by numpydoc !!

   .. py:method:: model_type() -> str

      
      Unique identifier given to the model, should be lower snake_cased name
















      ..
          !! processed by numpydoc !!

   .. py:method:: calc_lp_out_given_tokens_in(d_base: float, rate: float, market_state: elfpy.types.MarketState, time_remaining: elfpy.types.StretchedTime) -> tuple[float, float, float]

      
      Computes the amount of LP tokens to be minted for a given amount of base asset

      .. math::

      y = \frac{(z + \Delta z)(\mu \cdot (\frac{1}{1 + r \cdot t(d)})^{\frac{1}{\tau(d_b)}} - c)}{2}















      ..
          !! processed by numpydoc !!

   .. py:method:: calc_lp_in_given_tokens_out(d_base: float, rate: float, market_state: elfpy.types.MarketState, time_remaining: elfpy.types.StretchedTime) -> tuple[float, float, float]

      
      Computes the amount of LP tokens to be minted for a given amount of base asset
      .. math::
      y = \frac{(z - \Delta z)(\mu \cdot (\frac{1}{1 + r \cdot t(d)})^{\frac{1}{\tau(d_b)}} - c)}{2}
















      ..
          !! processed by numpydoc !!

   .. py:method:: calc_tokens_out_given_lp_in(lp_in: float, rate: float, market_state: elfpy.types.MarketState, time_remaining: elfpy.types.StretchedTime) -> tuple[float, float, float]

      
      Calculate how many tokens should be returned for a given lp addition
















      ..
          !! processed by numpydoc !!

   .. py:method:: calc_in_given_out(out: elfpy.types.Quantity, market_state: elfpy.types.MarketState, fee_percent: float, time_remaining: elfpy.types.StretchedTime) -> elfpy.types.TradeResult

      
      Calculates the amount of an asset that must be provided to receive a
      specified amount of the other asset given the current AMM reserves.

      The input is calculated as:

      .. math::
          in' =
          \begin{cases}
          c (\frac{1}{\mu} (\frac{k - (2y + cz - \Delta y)^{1-\tau}}{\frac{c}{\mu}})^{\frac{1}{1-\tau}} - z),
          &\text{ if } token\_in = \text{"base"} \\
          (k - \frac{c}{\mu} (\mu * (z - \Delta z))^{1 - \tau})^{\frac{1}{1 - \tau}} - (2y + cz),
          &\text{ if } token\_in = \text{"pt"}
          \end{cases} \\
          f =
          \begin{cases}
          (1 - \frac{1}{(\frac{2y + cz}{\mu z})^{\tau}}) \phi \Delta y, &\text{ if } token\_in = \text{"base"} \\
          (\frac{2y + cz}{\mu z})^{\tau} - 1) \phi (c \Delta z), &\text{ if } token\_in = \text{"pt"}
          \end{cases} \\
          in = in' + f

      :param out: The quantity of tokens that the user wants to receive (the amount
                  and the unit of the tokens).
      :type out: Quantity
      :param market_state: The state of the AMM's reserves and share prices.
      :type market_state: MarketState
      :param fee_percent: The percentage of the difference between the amount paid without
                          slippage and the amount received that will be added to the input
                          as a fee.
      :type fee_percent: float
      :param time_remaining: The time remaining for the asset (incorporates time stretch).
      :type time_remaining: StretchedTime

      :returns: * *float* -- The amount the user pays without fees or slippage. The units
                  are always in terms of bonds or base.
                * *float* -- The amount the user pays with fees and slippage. The units are
                  always in terms of bonds or base.
                * *float* -- The amount the user pays with slippage and no fees. The units are
                  always in terms of bonds or base.
                * *float* -- The fee the user pays. The units are always in terms of bonds or
                  base.















      ..
          !! processed by numpydoc !!

   .. py:method:: calc_out_given_in(in_: elfpy.types.Quantity, market_state: elfpy.types.MarketState, fee_percent: float, time_remaining: elfpy.types.StretchedTime) -> elfpy.types.TradeResult

      
      Calculates the amount of an asset that must be provided to receive a
      specified amount of the other asset given the current AMM reserves.

      The output is calculated as:

      .. math::
          out' =
          \begin{cases}
          c (z - \frac{1}{\mu} (\frac{k - (2y + cz + \Delta y)^{1 - \tau}}{\frac{c}{\mu}})^{\frac{1}{1 - \tau}}),
          &\text{ if } token\_out = \text{"base"} \\
          2y + cz - (k - \frac{c}{\mu} (\mu (z + \Delta z))^{1 - \tau})^{\frac{1}{1 - \tau}},
          &\text{ if } token\_out = \text{"pt"}
          \end{cases} \\
          f =
          \begin{cases}
          (1 - \frac{1}{(\frac{2y + cz}{\mu z})^{\tau}}) \phi \Delta y, &\text{ if } token\_out = \text{"base"} \\
          (\frac{2y + cz}{\mu z})^{\tau} - 1) \phi (c \Delta z), &\text{ if } token\_out = \text{"pt"}
          \end{cases} \\
          out = out' + f

      :param in_: The quantity of tokens that the user wants to pay (the amount
                  and the unit of the tokens).
      :type in_: Quantity
      :param market_state: The state of the AMM's reserves and share prices.
      :type market_state: MarketState
      :param fee_percent: The percentage of the difference between the amount paid without
                          slippage and the amount received that will be added to the input
                          as a fee.
      :type fee_percent: float
      :param time_remaining: The time remaining for the asset (incorporates time stretch).
      :type time_remaining: StretchedTime

      :returns: * *float* -- The amount the user receives without fees or slippage. The units
                  are always in terms of bonds or base.
                * *float* -- The amount the user receives with fees and slippage. The units are
                  always in terms of bonds or base.
                * *float* -- The amount the user receives with slippage and no fees. The units are
                  always in terms of bonds or base.
                * *float* -- The fee the user pays. The units are always in terms of bonds or
                  base.















      ..
          !! processed by numpydoc !!

   .. py:method:: _calc_k_const(market_state: elfpy.types.MarketState, time_remaining: elfpy.types.StretchedTime) -> decimal.Decimal

      
      Returns the 'k' constant variable for trade mathematics

      :param market_state: The state of the AMM
      :type market_state: MarketState
      :param time_remaining: Amount of time that remains in the current market
      :type time_remaining: StretchedTime

      :returns: 'k' constant used for trade mathematics, calculated from the provided parameters
      :rtype: Decimal















      ..
          !! processed by numpydoc !!


